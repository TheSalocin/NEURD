<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.whole_neuron_classifier_datajoint_adapted &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.whole_neuron_classifier_datajoint_adapted</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.whole_neuron_classifier_datajoint_adapted</h1><div class="highlight"><pre>
<span></span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">datajoint</span> <span class="k">as</span> <span class="nn">dj</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pymeshfix</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cgal_Segmentation_Module</span> <span class="k">as</span> <span class="nn">csm</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1">#for supressing the output</span>

<span class="c1">#for fixing the space issue with the CGAL:readoff</span>



<div class="viewcode-block" id="write_Whole_Neuron_Off_file"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.write_Whole_Neuron_Off_file">[docs]</a><span class="k">def</span> <span class="nf">write_Whole_Neuron_Off_file</span><span class="p">(</span><span class="n">neuron_ID</span><span class="p">,</span><span class="n">vertices</span><span class="o">=</span><span class="p">[],</span> <span class="n">triangles</span><span class="o">=</span><span class="p">[]):</span>
    <span class="c1">#primary_key = dict(segmentation=1, segment_id=segment_id, decimation_ratio=0.35)</span>
    <span class="c1">#vertices, triangles = (mesh_Table_35 &amp; primary_key).fetch1(&#39;vertices&#39;, &#39;triangles&#39;)</span>
    
    <span class="n">num_vertices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>
    <span class="n">num_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span>
    
    <span class="c1">#get the current file location</span>
    
    <span class="n">file_loc</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&quot;temp&quot;</span>
    <span class="n">file_loc</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuron_ID</span><span class="p">)</span>
    <span class="n">path_and_filename</span> <span class="o">=</span> <span class="n">file_loc</span> <span class="o">/</span> <span class="n">filename</span>
    
    <span class="c1">#print(file_loc)</span>
    <span class="c1">#print(path_and_filename)</span>
    
    <span class="c1">#open the file and start writing to it    </span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path_and_filename</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.off&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;OFF</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_faces</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; 0</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="p">)</span>
    
    
    <span class="c1">#iterate through and write all of the vertices in the file</span>
    <span class="k">for</span> <span class="n">verts</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#print(&quot;Done writing verts&quot;)</span>
        
    <span class="k">for</span> <span class="n">faces</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;3 &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done writing OFF file&quot;</span><span class="p">)</span>
    <span class="c1">#f.write(&quot;end&quot;)</span>
    
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">path_and_filename</span><span class="p">)</span><span class="c1">#,str(filename),str(file_loc)</span></div>

<span class="c1">#class that will handle the whole neuron segmentation:</span>
<div class="viewcode-block" id="WholeNeuronClassifier"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier">[docs]</a><span class="k">class</span> <span class="nc">WholeNeuronClassifier</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="WholeNeuronClassifier.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh_file_location</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">import_Off_Flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">pymeshfix_Flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">joincomp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">remove_smallest_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">vertices</span><span class="o">=</span><span class="p">[],</span><span class="n">triangles</span><span class="o">=</span><span class="p">[],</span><span class="n">segment_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        imports mesh from off file and runs the pymeshfix algorithm to get of any unwanted portions of mesh</span>
<span class="sd">        (particularly used to get rid of basketball like debris that is sometimes inside soma)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">import_Off_Flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            
            <span class="n">full_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">mesh_file_location</span><span class="p">)</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span>

            <span class="c1">#get the vertices to faces lookup table</span>

            <span class="n">original_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> 
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading mesh from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">))</span>

                <span class="n">my_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="n">my_mesh</span><span class="o">.</span><span class="n">vertices</span>
                <span class="n">faces</span> <span class="o">=</span> <span class="n">my_mesh</span><span class="o">.</span><span class="n">faces</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; was not a valid file&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Import Off file flag was set but path was invalid file path&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">vertices</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">triangles</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">segment_id</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;loading mesh from vertices and triangles array&quot;</span><span class="p">)</span>
            <span class="c1">#check that neither are not empty</span>




            <span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">triangles</span>


            <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">triangles</span>



<span class="w">            </span><span class="sd">&quot;&quot;&quot;  How you would load from datajoint </span>
<span class="sd">            print(&quot;Loading mesh from datajoint- id: &quot; + str(key[&quot;segment_id&quot;]))</span>

<span class="sd">            segment_id = key[&quot;segment_id&quot;]</span>
<span class="sd">            decimation_ratio = key.pop(&quot;decimation_ratio&quot;,0.35)</span>
<span class="sd">            segmentation = key.pop(&quot;segmentation&quot;,2)</span>

<span class="sd">            primary_key = dict(segmentation=segmentation,decimation_ratio=decimation_ratio,segment_id=segment_id)</span>
<span class="sd">            neuron_data = (ta3p100.CleansedMesh &amp; primary_key).fetch1()</span>

<span class="sd">            print(neuron_data)</span>
<span class="sd">            vertices = neuron_data[&#39;vertices&#39;]#.astype(dtype=np.int32)</span>
<span class="sd">            faces = neuron_data[&#39;triangles&#39;]#.astype(dtype=np.uint32)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            


        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid key or filename given&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; VERTICES AND/OR TRIANGLES ARRAY WAS EMPTY&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Import Off file flag was NOT set but arrays passed for verts and faces were empty&quot;</span><span class="p">)</span>
            <span class="c1">#raise Exception(&quot;No valid key or filename given&quot;)</span>
        
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span>
        
        <span class="k">if</span> <span class="n">pymeshfix_Flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#pymeshfix step</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting pymeshfix algorithm&quot;</span><span class="p">)</span>
            <span class="n">meshfix</span> <span class="o">=</span> <span class="n">pymeshfix</span><span class="o">.</span><span class="n">MeshFix</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">faces</span><span class="p">)</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
            <span class="n">meshfix</span><span class="o">.</span><span class="n">repair</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">joincomp</span><span class="p">,</span><span class="n">remove_smallest_components</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished pymeshfix algorithm: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">meshfix</span><span class="o">.</span><span class="n">v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">meshfix</span><span class="o">.</span><span class="n">f</span>
        
<span class="c1">#         #------To load local pymeshfix mesh so don&#39;t have to wait for it to do it again----#</span>
<span class="c1">#         print(&quot;Loading local pymeshfixed mesh&quot;)</span>
<span class="c1">#         temp_mesh = trimesh.load_mesh(&quot;temp/neuron_&quot; + str(648518346341393609) + &quot;_fixed.off&quot;)</span>
<span class="c1">#         self.vertices = temp_mesh.vertices</span>
<span class="c1">#         self.faces = temp_mesh.faces</span>
<span class="c1">#         #------End of local pymesh import----#</span>
        
        

        <span class="n">trimesh_object</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()</span>
        <span class="n">trimesh_object</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
        <span class="n">trimesh_object</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh_object</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_file_location</span> <span class="o">=</span> <span class="n">mesh_file_location</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">file_name</span></div>
    
<div class="viewcode-block" id="WholeNeuronClassifier.generate_verts_to_face_dictionary"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.generate_verts_to_face_dictionary">[docs]</a>    <span class="k">def</span> <span class="nf">generate_verts_to_face_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labels_list</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates 2 dictionary mapping for vertices:</span>
<span class="sd">        1) verts_to_Face: maps each vertex to all the faces it touches</span>
<span class="sd">        2) verts_to_Label: maps each vertex to all the unique face labels it touches</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_list</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#print(&quot;len(labels_list) &lt;= 1&quot;)</span>
            <span class="n">labels_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span>
        
        <span class="n">verts_to_Face</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)}</span>
        <span class="n">verts_to_Label</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vertex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)}</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">verts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">):</span>
            
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                <span class="n">verts_to_Face</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1">#use the verts to face to create the verts to label dictionary</span>
        <span class="k">for</span> <span class="n">vert</span><span class="p">,</span><span class="n">face_list</span> <span class="ow">in</span> <span class="n">verts_to_Face</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">diff_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_list</span><span class="p">[</span><span class="n">fc</span><span class="p">]</span> <span class="k">for</span> <span class="n">fc</span> <span class="ow">in</span> <span class="n">face_list</span><span class="p">]</span>
            <span class="c1">#print(list(set(diff_labels)))</span>
            <span class="n">verts_to_Label</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">diff_labels</span><span class="p">))</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">verts_to_Face</span> <span class="o">=</span> <span class="n">verts_to_Face</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verts_to_Label</span> <span class="o">=</span> <span class="n">verts_to_Label</span>
        
        <span class="c1">#print(&quot;inside generate verts_to_face&quot;)</span>

        <span class="k">return</span></div>
    
    
    
    <span class="c1">#write the faces and vertices to an off file</span>
<div class="viewcode-block" id="WholeNeuronClassifier.export_self_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.export_self_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">export_self_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file_path_and_name</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">,</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">file_path_and_name</span><span class="p">)</span></div>
    
    <span class="c1">#Step 2</span>
<div class="viewcode-block" id="WholeNeuronClassifier.load_cgal_segmentation"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.load_cgal_segmentation">[docs]</a>    <span class="k">def</span> <span class="nf">load_cgal_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">smoothness</span><span class="o">=</span><span class="mf">0.20</span><span class="p">,</span><span class="n">import_CGAL_Flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">import_CGAL_paths</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">],[</span><span class="s2">&quot;&quot;</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the cgal surface mesh segmentation on the mesh object and writes it to a temporary file</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#have to write the new mesh to an off file</span>
<span class="c1">#         new_mesh_file_path_and_name = str(Path(self.mesh_file_location) /</span>
<span class="c1">#                                             Path(self.file_name[:-4] + &quot;_fixed.off&quot;))</span>
        
<span class="c1">#         self.export_self_mesh(new_mesh_file_path_and_name)</span>
<span class="c1">#         #add an extra end line to the off file</span>
<span class="c1">#         with open(new_mesh_file_path_and_name,&#39;a&#39;) as fd:</span>
<span class="c1">#             fd.write(&quot;\n&quot;)</span>
        
    
        <span class="k">if</span> <span class="n">import_CGAL_Flag</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">path_and_filename</span> <span class="o">=</span> <span class="n">write_Whole_Neuron_Off_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_fixed&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">path_and_filename</span> <span class="o">=</span> <span class="n">write_Whole_Neuron_Off_file</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_fixed&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Neither File name nor Segment Id set by time reaches load_cgal_segmentation&quot;</span><span class="p">)</span>



<span class="w">            </span><span class="sd">&quot;&quot;&quot;skip the segmentation for now&quot;&quot;&quot;</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">cgal_Flag</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Starting CGAL segmentation&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cgal_Flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Right before cgal segmentation, clusters = </span><span class="si">{</span><span class="n">clusters</span><span class="si">}</span><span class="s2">, smoothness = </span><span class="si">{</span><span class="n">smoothness</span><span class="si">}</span><span class="s2">, path_and_filename = </span><span class="si">{</span><span class="n">path_and_filename</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">csm</span><span class="o">.</span><span class="n">cgal_segmentation</span><span class="p">(</span><span class="n">path_and_filename</span><span class="p">,</span><span class="n">clusters</span><span class="p">,</span><span class="n">smoothness</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished CGAL segmentation algorithm: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_file</span> <span class="o">=</span> <span class="n">path_and_filename</span> <span class="o">+</span> <span class="s2">&quot;-cgal_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smoothness</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">sdf_file</span> <span class="o">=</span> <span class="n">path_and_filename</span> <span class="o">+</span> <span class="s2">&quot;-cgal_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smoothness</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_sdf.csv&quot;</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#check that the paths exist in the import</span>
            <span class="k">for</span> <span class="n">path_c</span> <span class="ow">in</span> <span class="n">import_CGAL_paths</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path_c</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path_c</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is not a valid path for cgal import&quot;</span><span class="p">)</span>

            <span class="c1">#import the cgal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_file</span> <span class="o">=</span> <span class="n">import_CGAL_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sdf_file</span> <span class="o">=</span> <span class="n">import_CGAL_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            
        
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smoothness</span> <span class="o">=</span> <span class="n">smoothness</span>
<span class="c1">#         self.labels_file = str(Path(self.mesh_file_location) / Path(self.file_name[:-4] + &quot;_fixed&quot; + &quot;-cgal_&quot; + str(np.round(clusters,2)) + &quot;_&quot; + &quot;{:.2f}&quot;.format(smoothness) + &quot;.csv&quot; ))  </span>
<span class="c1">#         self.sdf_file = str(Path(self.mesh_file_location) / Path(self.file_name[:-4] + &quot;_fixed&quot; + &quot;-cgal_&quot; + str(clusters) + &quot;_&quot; + &quot;{:.2f}&quot;.format(smoothness) + &quot;_sdf.csv&quot; ))  </span>
<span class="c1">#         #print(f&quot;Step 2: CGAL segmentation total time ---- {np.round(time.time() - start_time,5)} seconds&quot;)</span>
 
        <span class="k">return</span></div>
        
        
    <span class="c1">#used for when not pulling from datajoint</span>
<div class="viewcode-block" id="WholeNeuronClassifier.get_cgal_data_and_label_local_optomized"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.get_cgal_data_and_label_local_optomized">[docs]</a>    <span class="k">def</span> <span class="nf">get_cgal_data_and_label_local_optomized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the cgal segmentation stored in the temporary file into the object</span>
<span class="sd">        And remaps the labels from CGAL file to numerical </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">labels_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_file</span>
        <span class="n">sdf_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_file</span>
        
        <span class="c1">#reads int the cgal labels for all of the faces</span>
        <span class="n">triangles_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">labels_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">csvfile</span><span class="p">)):</span>
                <span class="n">triangles_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


        <span class="c1">#converts the cgal labels into a list that</span>
        <span class="c1"># starts at 0</span>
        <span class="c1"># progresses in order for all unique labels (so no numbers are skipped and don&#39;t have corresponding face)</span>
        <span class="n">verts_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">faces_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span>
        <span class="c1">#gets a list of the unique labels</span>
        <span class="n">unique_segments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">triangles_labels</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">segmentation_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)</span> 
        <span class="n">unique_index_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">unique_segments</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">segmentation_length</span> <span class="p">)}</span>
        
        <span class="n">labels_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">triangles_labels</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">tri</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles_labels</span><span class="p">):</span>

            <span class="c1">#assembles the label list that represents all of the faces</span>
            <span class="n">labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">unique_index_dict</span><span class="p">[</span><span class="n">tri</span><span class="p">])</span>

        <span class="c1">#write thses new labels to a file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">labels_file</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_revised.csv&quot;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>
            <span class="n">csv_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">csvfile</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">labels_list</span><span class="p">:</span>
                <span class="n">csv_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>

        <span class="c1">#print(&quot;done with cgal_segmentation&quot;)</span>

        <span class="c1">#----------------------now return a dictionary of the sdf values like in the older function get_sdf_dictionary</span>
        <span class="c1">#get the sdf values and store in sdf_labels</span>
        <span class="n">sdf_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_list</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sdf_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">csvfile</span><span class="p">)):</span>
                <span class="n">sdf_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        
        <span class="n">sdf_temp_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">segmentation_length</span><span class="p">):</span>
            <span class="n">sdf_temp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        
        <span class="c1">#iterate through the labels_list</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels_list</span><span class="p">):</span>
            <span class="n">sdf_temp_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdf_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1">#print(sdf_temp_dict)</span>

        <span class="c1">#now calculate the stats on the sdf values for each label</span>
        <span class="n">sdf_final_dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">dict_key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">sdf_temp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">dict_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">median</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">value</span><span class="p">),</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">value</span><span class="p">),</span><span class="nb">max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                                           <span class="n">n_faces</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span> <span class="o">=</span> <span class="n">sdf_final_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">=</span> <span class="n">labels_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_list_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">labels_list</span><span class="p">)</span>
    
<span class="c1">#         adjacency_labels = self.labels_list[self.mesh.face_adjacency]</span>
        
<span class="c1">#         self.adjacency_labels_col1, self.adjacency_labels_col2 = adjacency_labels.T</span>
        <span class="c1">#generate the vertices labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_verts_to_face_dictionary</span><span class="p">(</span><span class="n">labels_list</span><span class="p">)</span>
        
        <span class="k">return</span> </div>
        
    
    <span class="c1">#Step 3</span>
<div class="viewcode-block" id="WholeNeuronClassifier.get_highest_sdf_part"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.get_highest_sdf_part">[docs]</a>    <span class="k">def</span> <span class="nf">get_highest_sdf_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">size_threshold</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span><span class="n">exclude_label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Based ont the sdf data and the labels data,</span>
<span class="sd">        Finds the label with the highest median,</span>
<span class="sd">            label with highest max,</span>
<span class="sd">            label with highest mean sdf value</span>
<span class="sd">        </span>
<span class="sd">        *** but only for those that meet the certain threshold ***</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">high_median_val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">high_median</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">high_mean_val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">high_mean</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">high_max_val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">high_max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>



        <span class="c1">#gets all of the labels</span>
        <span class="n">my_list</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span><span class="p">)</span>
        <span class="n">my_list_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">my_list</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">exclude_label</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">my_list_keys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">exclude_label</span><span class="p">)</span>

        <span class="c1">#OPTOMIZE</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;my_list_keys = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">my_list_keys</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_list_keys</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">high_median_val</span> <span class="ow">and</span> <span class="n">my_list</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size_threshold</span><span class="p">:</span>
                <span class="n">high_median</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">high_median_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;changed the median value&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">high_mean_val</span>  <span class="ow">and</span> <span class="n">my_list</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size_threshold</span><span class="p">:</span>
                <span class="n">high_mean</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">high_mean_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;changed the mean value&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">high_max_val</span>  <span class="ow">and</span> <span class="n">my_list</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">size_threshold</span><span class="p">:</span>
                <span class="n">high_max</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">high_max_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s2">&quot;max&quot;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;changed the max value&quot;</span><span class="p">)</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">highest_vals</span><span class="o">=</span> <span class="p">[</span><span class="n">high_median</span><span class="p">,</span><span class="n">high_median_val</span><span class="p">,</span><span class="n">high_mean</span><span class="p">,</span><span class="n">high_mean_val</span><span class="p">,</span><span class="n">high_max</span><span class="p">,</span><span class="n">high_max_val</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">high_median</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highest_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_median</span><span class="p">,</span><span class="n">high_median_val</span><span class="c1"># returns the highest median and the highest median value</span></div>


    <span class="c1">#Step 3</span>
<div class="viewcode-block" id="WholeNeuronClassifier.get_graph_structure"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.get_graph_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_graph_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each unique label gets:</span>
<span class="sd">        1) all neighbors</span>
<span class="sd">        2) number of faces belonging to that label</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">connections</span> <span class="o">=</span> <span class="p">{</span><span class="n">label_name</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">label_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_list_counter</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">mesh_Number</span> <span class="o">=</span> <span class="p">{</span><span class="n">label_name</span><span class="p">:</span><span class="n">number</span> <span class="k">for</span> <span class="n">label_name</span><span class="p">,</span><span class="n">number</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_list_counter</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1">#label_vert_stats = {label_name:[300000,-300000] for label_name in Counter(labels_list).keys()}</span>

        <span class="c1">#verts to label curently is the has every vertex and the labels it is toughing in a list</span>
        <span class="k">for</span> <span class="n">verts</span><span class="p">,</span><span class="n">total_labels</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verts_to_Label</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#if more than one label</span>
                <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">total_labels</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fc</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">total_labels</span> <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">face</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">fc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">[</span><span class="n">face</span><span class="p">]:</span>
                            <span class="n">connections</span><span class="p">[</span><span class="n">face</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connections</span> <span class="o">=</span> <span class="n">connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_Number</span> <span class="o">=</span> <span class="n">mesh_Number</span>
        

        <span class="k">return</span> </div>
    
    <span class="c1">#Step 4</span>
<div class="viewcode-block" id="WholeNeuronClassifier.find_Soma_Caps"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.find_Soma_Caps">[docs]</a>    <span class="k">def</span> <span class="nf">find_Soma_Caps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma_index</span><span class="p">,</span><span class="n">min_width</span><span class="o">=</span><span class="mf">0.23</span><span class="p">,</span><span class="n">max_faces</span><span class="o">=</span><span class="mi">6000</span><span class="p">,</span><span class="n">max_n_connection</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">large_extension_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span><span class="n">large_extension_convex_max</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Will identify and relabel soma extensions that are created when using clusters of size 4 or higher</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#get the soma neighbors</span>
        <span class="n">soma_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="n">soma_index</span><span class="p">]</span>
        
        <span class="n">total_soma_caps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">soma_neighbors</span><span class="p">:</span>
            <span class="n">soma_cap</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="c1">#collect the mesh of the cap</span>
            <span class="n">submesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">i</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">mean_convex</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">convex</span><span class="o">.</span><span class="n">adjacency_projections</span><span class="p">(</span><span class="n">submesh</span><span class="p">)))</span>
            <span class="n">n_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">submesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="n">width_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">width_data_median</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span>
            <span class="n">n_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
          
            
            <span class="k">if</span> <span class="n">width_data</span><span class="p">[</span><span class="s2">&quot;median&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_width</span> <span class="ow">or</span> <span class="n">n_faces</span><span class="o">&gt;</span><span class="n">max_faces</span> <span class="ow">or</span> <span class="n">n_connections</span><span class="o">&gt;</span><span class="n">max_n_connection</span><span class="p">:</span> 
                <span class="n">soma_cap</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="c1">#use the convex data if size is really big:</span>
            <span class="k">if</span> <span class="n">n_faces</span> <span class="o">&gt;</span> <span class="n">large_extension_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mean_convex</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="c1">#print(f&quot; {i} Doesn&#39;t meet second pass&quot;)</span>
                    <span class="n">soma_cap</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="k">if</span> <span class="n">soma_cap</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">total_soma_caps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            

        <span class="c1">#for all the soma caps replace the labels list with soma_index and recompute neighbors and connections:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_soma_caps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_soma_caps</span><span class="p">)</span><span class="si">}</span><span class="s2"> soma caps and replacing labels: </span><span class="si">{</span><span class="n">total_soma_caps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span><span class="p">,</span><span class="n">total_soma_caps</span><span class="p">))]</span> <span class="o">=</span> <span class="n">soma_index</span>
            
            
<span class="c1">#             #write thses new labels to a file</span>
<span class="c1">#             with open(self.labels_file[:-4] + &quot;_revised.csv&quot;,mode=&quot;w&quot;) as csvfile:</span>
<span class="c1">#                 csv_writer = csv.writer(csvfile,delimiter=&#39;,&#39;)</span>
<span class="c1">#                 for i in self.labels_list:</span>
<span class="c1">#                     csv_writer.writerow([i])</span>
            <span class="c1">#call the functions to recompute the connections/neighbors and others (but don&#39;t need to generate SDF labels again)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_list_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span><span class="p">)</span>

            <span class="c1">#generate the vertices labels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_verts_to_face_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">get_graph_structure</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;done replacing soma cap labels : </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
            
    <span class="c1">#Step 5</span>
<div class="viewcode-block" id="WholeNeuronClassifier.find_Apical"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.find_Apical">[docs]</a>    <span class="k">def</span> <span class="nf">find_Apical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma_index</span><span class="p">,</span><span class="n">apical_mesh_threshold</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                        <span class="n">apical_height_threshold</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                                           <span class="n">apical_sdf_threshold</span> <span class="o">=</span> <span class="mf">0.09</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the index of the most likely apical </span>
<span class="sd">        1) calculate the height of 70% up the soma</span>
<span class="sd">        2) find all the neighbors of the soma using verts_to_Label</span>
<span class="sd">        3) filter out the neighbors that go below that</span>
<span class="sd">        4) filter away the neighbors that don&#39;t meet minimum number of face, height change and sdf median</span>
<span class="sd">        5) If multiple, pick the one that has the most number of neighbors</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Soma Index = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">soma_index</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Soma Connections = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="n">soma_index</span><span class="p">]))</span>
        <span class="n">mesh_Threshold</span> <span class="o">=</span> <span class="n">apical_mesh_threshold</span>
        <span class="n">height_Threshold</span> <span class="o">=</span><span class="n">apical_height_threshold</span>
        <span class="n">sdf_Threshold</span> <span class="o">=</span> <span class="n">apical_sdf_threshold</span>
        <span class="c1">#1) calculate the height of 70% up the soma (but have to adjust because the negative direction of y is </span>
        <span class="c1">#direction of the apical), this new method gets the height of the first 30% of the somae which is actually</span>
        <span class="c1"># the top 30% of the soma once it is flipped in the right orientation</span>

        <span class="n">soma_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">soma_index</span><span class="p">)]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()][:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">soma_y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">soma_verts</span><span class="p">)</span>
        <span class="n">soma_y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">soma_verts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soma_y_min</span> <span class="o">=</span> <span class="n">soma_y_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soma_y_max</span> <span class="o">=</span> <span class="n">soma_y_max</span>
<span class="c1">#         print(&quot;soma_y_max =&quot;  + str(soma_y_max))</span>
<span class="c1">#         print(&quot;soma_y_min =&quot;  + str(soma_y_min))</span>
        
        
        <span class="n">soma_80_percent</span> <span class="o">=</span> <span class="p">(</span><span class="n">soma_y_max</span> <span class="o">-</span> <span class="n">soma_y_min</span><span class="p">)</span><span class="o">*</span><span class="mf">0.3</span> <span class="o">+</span>  <span class="n">soma_y_min</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;soma_80_percent = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">soma_80_percent</span><span class="p">))</span>
        
        <span class="c1">#2) find all the neighbors of the soma using verts_to_Label</span>
        <span class="n">soma_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="n">soma_index</span><span class="p">]</span>
        
        <span class="c1">#3) filter out the neighbors that go below that</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Debugging the axon filter&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">([(</span><span class="n">label</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">label</span><span class="p">)]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()][:,</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">soma_neighbors</span><span class="p">])</span>
        <span class="n">possible_Axons_filter_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">soma_neighbors</span> 
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">label</span><span class="p">)]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()][:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">soma_80_percent</span><span class="p">]</span>

        <span class="c1">#4) filter away the neighbors that don&#39;t meet minimum number of face, height change and sdf median</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;possible_Axons_filter_1 = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">possible_Axons_filter_1</span><span class="p">))</span>
        <span class="n">possible_Axons_filter_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">possible_Axons_filter_1</span> <span class="k">if</span> 
                                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_Number</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mesh_Threshold</span> <span class="ow">and</span> 
        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">lab</span><span class="p">)]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()][:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">lab</span><span class="p">)]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()][:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">height_Threshold</span> <span class="ow">and</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">lab</span><span class="p">][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sdf_Threshold</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;possible_Axons_filter_2 = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">possible_Axons_filter_2</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_Axons_filter_2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_Axons_filter_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">possible_Axons_filter_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
<span class="c1">#             #find the one with the most neighbors</span>
<span class="c1">#             current_apical = possible_Axons_filter_2[0]</span>
<span class="c1">#             current_apical_neighbors = len(self.connections[possible_Axons_filter_2[0]])</span>
<span class="c1">#             for i in range(1,len(possible_Axons_filter_2)):</span>
<span class="c1">#                 if len(self.connections[possible_Axons_filter_2[i]]) &gt; current_apical_neighbors:</span>
<span class="c1">#                     current_apical = possible_Axons_filter_2[i]</span>
<span class="c1">#                     current_apical_neighbors = len(self.connections[possible_Axons_filter_2[i]])</span>
                    
            <span class="c1">#--&gt; revised now does the one with the highest thickness</span>
            <span class="c1">##### MIGHT WANT TO ADD IN WHERE FINDS THE THICKEST WIDTH !</span>
            
            <span class="n">current_apical</span> <span class="o">=</span> <span class="n">possible_Axons_filter_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">current_apical_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">current_apical</span><span class="p">][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span>
            
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">possible_Axons_filter_2</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">possible_Axons_filter_2</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">current_apical_width</span><span class="p">:</span>
                    <span class="n">current_apical</span> <span class="o">=</span> <span class="n">possible_Axons_filter_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">current_apical_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdf_final_dict</span><span class="p">[</span><span class="n">possible_Axons_filter_2</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s2">&quot;median&quot;</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">current_apical</span></div>
    
    
    <span class="c1">#step 6</span>
<div class="viewcode-block" id="WholeNeuronClassifier.classify_whole_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.classify_whole_neuron">[docs]</a>    <span class="k">def</span> <span class="nf">classify_whole_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">possible_Apical</span><span class="p">,</span><span class="n">soma_index</span><span class="p">,</span>
                             <span class="n">classifier_cilia_threshold</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                             <span class="n">classifier_stub_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                             <span class="n">classifier_non_dendrite_convex_threshold</span> <span class="o">=</span> <span class="mf">27.5</span><span class="p">,</span>
                             <span class="n">classifier_axon_std_dev_threshold</span> <span class="o">=</span> <span class="mi">69</span><span class="p">,</span>
                             <span class="n">classifier_stub_threshold_apical</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span>
                             <span class="n">soma_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Will use the soma index and apical index to label the rest of the segmentation portions</span>
<span class="sd">        with the appropriate category: Apical, Soma stub, cilia, basal, dendrite, axon, etc.</span>
<span class="sd">        </span>
<span class="sd">        Parameteres:</span>
<span class="sd">        classifier_cilia_threshold #maximum size of cilia</span>
<span class="sd">        classifier_stub_threshold # minimum size of appndage of soma to not be considered stub and merged with the soma</span>
<span class="sd">        classifier_non_dendrite_convex_threshold #must be above this value to be axon, cilia or error</span>
<span class="sd">        </span>
<span class="sd">        classifier_stub_threshold_apical #the minimum size threshold for apical appendage not to be merged with apical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#check to see if no soma index</span>
        <span class="k">if</span> <span class="n">soma_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">whole_neuron_labels</span> <span class="o">=</span><span class="p">{</span><span class="n">lb</span><span class="p">:</span><span class="s2">&quot;unsure&quot;</span> <span class="k">for</span> <span class="n">lb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
            <span class="k">return</span>
        
        <span class="c1">#creates dictionary with unique labels whose value will store their final label</span>
        <span class="n">whole_neuron_labels</span> <span class="o">=</span><span class="p">{</span><span class="n">lb</span><span class="p">:</span><span class="s2">&quot;unsure&quot;</span> <span class="k">for</span> <span class="n">lb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">soma_index</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;soma&quot;</span>
        
        <span class="k">if</span> <span class="n">soma_only</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">whole_neuron_labels</span> <span class="o">=</span> <span class="n">whole_neuron_labels</span>
            <span class="k">return</span>

        <span class="c1">#create a networkx graph based on connections</span>
        <span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">)</span>

        
        <span class="c1">#removes the soma from the list of nodes, but not actually remove it from the graph</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">soma_index</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">):</span>
            <span class="n">node_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">soma_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#didn&#39;t find soma</span>
            <span class="k">return</span> <span class="p">[]</span>

        
        <span class="c1">#finds the shortest path from any label to the soma</span>
        <span class="n">shortest_paths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="n">shortest_paths</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">soma_index</span><span class="p">)]</span>

        <span class="c1">#find the direct neighbors of the soma</span>
        <span class="n">soma_branches</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">soma_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="n">soma_index</span><span class="p">]</span>
        
        
        <span class="c1">#print(&quot;soma_neighbors = &quot; + str(soma_neighbors))</span>
        
        <span class="c1">#assemble each of these compartments into groups</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">path</span> <span class="ow">in</span> <span class="n">shortest_paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">possible_Apical</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">specific_soma_neighbor</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">soma_neighbors</span><span class="p">)))</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">specific_soma_neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">soma_branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">soma_branches</span><span class="p">[</span><span class="n">specific_soma_neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">soma_branches</span><span class="p">[</span><span class="n">specific_soma_neighbor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        

        <span class="c1">#print(&quot;soma_branches = &quot; + str(soma_branches))</span>
        <span class="c1">#have groups of branches and assmble them into trimesh objects</span>
        <span class="n">branches_submeshes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">group_list</span> <span class="ow">in</span> <span class="n">soma_branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">total_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group_list</span><span class="p">:</span>
                <span class="n">face_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">g</span><span class="p">)</span>
                <span class="n">total_indices</span> <span class="o">+=</span> <span class="n">face_indices</span>
            
            <span class="c1">#create a trimesh submshesh</span>
            <span class="n">branches_submeshes</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">total_indices</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        
        <span class="c1">#iterate through meshes and assign certain labels to these guys</span>
        <span class="c1">## define certain thresholds for determining label</span>
        <span class="n">cilia_threshold</span> <span class="o">=</span> <span class="n">classifier_cilia_threshold</span> <span class="c1">#maximum size of cilia</span>
        <span class="n">stub_threshold</span> <span class="o">=</span> <span class="n">classifier_stub_threshold</span> <span class="c1"># minimum size of appndage of soma to not be considered stub and merged with the soma</span>
        <span class="n">non_dendrite_convex_threshold</span> <span class="o">=</span> <span class="n">classifier_non_dendrite_convex_threshold</span> <span class="c1">#must be above this value to be axon, cilia or error</span>

        
        <span class="c1">#Calculate the soma 30% that axon must be lower than</span>

        
        <span class="n">soma_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma_y_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma_y_min</span>
        
        <span class="n">soma_lower_30</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma_y_max</span> <span class="o">-</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">soma_height</span>
<span class="c1">#         print(&quot;self.soma_y_max = &quot; + str(self.soma_y_max))</span>
<span class="c1">#         print(&quot;self.soma_y_min = &quot; + str(self.soma_y_min))</span>
<span class="c1">#         print(&quot;soma_lower_30 = &quot; + str(soma_lower_30))</span>
        
        
        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span><span class="n">submesh</span> <span class="ow">in</span> <span class="n">branches_submeshes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            
            <span class="c1">#get the number of faces</span>
            <span class="n">total_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">submesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="c1">#print(f&quot;total_faces  = {total_faces}&quot;)</span>
            
            <span class="k">if</span> <span class="n">total_faces</span> <span class="o">&lt;</span> <span class="n">stub_threshold</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2"> = stub soma&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">soma_branches</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    
                    <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;soma&quot;</span>
            <span class="k">else</span><span class="p">:</span>
            
                <span class="n">mean_convex</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">convex</span><span class="o">.</span><span class="n">adjacency_projections</span><span class="p">(</span><span class="n">submesh</span><span class="p">)))</span>
                <span class="c1">#print(f&quot;total_faces  = {mean_convex}&quot;)</span>
                <span class="k">if</span> <span class="n">mean_convex</span> <span class="o">&gt;</span> <span class="n">non_dendrite_convex_threshold</span><span class="p">:</span>
                    <span class="c1">#print(&quot;neighbor inside cilia check = &quot; + str(neighbor))</span>
                    <span class="c1">#classify according to size</span>

                    <span class="k">if</span> <span class="n">total_faces</span> <span class="o">&lt;</span> <span class="n">cilia_threshold</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2"> = cilia&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">soma_branches</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                            <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cilia&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2"> = error&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">soma_branches</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                            <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#try to see if there is any axon</span>
                    <span class="c1">#calculate the standard deviation</span>
                    <span class="c1">#print(&quot;neighbor inside axon check = &quot; + str(neighbor))</span>
                    <span class="n">std_dev_convex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">((</span><span class="n">trimesh</span><span class="o">.</span><span class="n">convex</span><span class="o">.</span><span class="n">adjacency_projections</span><span class="p">(</span><span class="n">submesh</span><span class="p">)))</span>
                    
                    <span class="k">if</span> <span class="n">std_dev_convex</span> <span class="o">&lt;</span> <span class="n">classifier_axon_std_dev_threshold</span><span class="p">:</span>
                        <span class="c1">#find the minimum y heght of neighbor</span>
                        <span class="n">neighbor_y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">neighbor</span><span class="p">)]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()][:,</span><span class="mi">1</span><span class="p">])</span>
                        <span class="c1">###Don&#39;t need the maximum anymore</span>
                        <span class="c1">##neighbor_y_max = np.max(self.vertices[self.faces[np.where(self.labels_list == neighbor)].ravel()][:,1])</span>
                        <span class="c1">#print(&quot;neighbor_y_min = &quot; + str(neighbor_y_min))</span>
                        <span class="c1">#print(&quot;neighbor_y_max = &quot; + str(neighbor_y_max))</span>
                        
                        <span class="k">if</span> <span class="n">neighbor_y_min</span> <span class="o">&gt;</span> <span class="n">soma_lower_30</span><span class="p">:</span>
                            <span class="c1">#make sure that it doesn&#39;t go higher than 40% soma height</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2"> = axon&quot;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">soma_branches</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                                <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;axon&quot;</span>
                                
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MET AXON THRESHOLD CRITERIA but not low enough on soma for neighbor = </span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            
        
        <span class="c1"># checks if apical is present or not, and if not then just labels everything else basal</span>
        <span class="k">if</span> <span class="n">possible_Apical</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
            <span class="c1">#label everything as basal if don&#39;t know</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">vals</span> <span class="ow">in</span> <span class="n">whole_neuron_labels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">soma_index</span> <span class="ow">and</span> <span class="n">vals</span> <span class="o">==</span> <span class="s2">&quot;unsure&quot;</span><span class="p">:</span>
                    <span class="c1">#whole_neuron_labels[k] = &quot;basal&quot;</span>
                    <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">whole_neuron_labels</span> <span class="o">=</span> <span class="n">whole_neuron_labels</span>
            
            <span class="k">return</span> 
                    
            
        <span class="c1">#return branches_submeshes</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; 4-29 added edition that will prevent small spines off of apical </span>
<span class="sd">        from being considered oblique branches</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#find the direct neighbors of the soma</span>
        <span class="n">apical_branches</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">apical_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="n">possible_Apical</span><span class="p">]</span>
        <span class="n">apical_neighbors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">soma_index</span><span class="p">)</span>
        
        
        <span class="c1">#assemble each of these compartments into groups</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">path</span> <span class="ow">in</span> <span class="n">shortest_paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">possible_Apical</span> <span class="ow">in</span> <span class="n">path</span> <span class="ow">and</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">possible_Apical</span><span class="p">:</span> <span class="c1">#make sure only those obliques and not actual apical</span>
                
                <span class="n">specific_apical_neighbor</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">apical_neighbors</span><span class="p">)))</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">specific_apical_neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">apical_branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">apical_branches</span><span class="p">[</span><span class="n">specific_apical_neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">apical_branches</span><span class="p">[</span><span class="n">specific_apical_neighbor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        

        <span class="c1">#print(&quot;apical_branches = &quot; + str(apical_branches))</span>
        <span class="c1">#have groups of branches and assmble them into trimesh objects</span>
        <span class="n">branches_submeshes_apical</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">group</span><span class="p">,</span><span class="n">group_list</span> <span class="ow">in</span> <span class="n">apical_branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">total_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group_list</span><span class="p">:</span>
                <span class="n">face_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span> <span class="o">==</span> <span class="n">g</span><span class="p">)</span>
                <span class="n">total_indices</span> <span class="o">+=</span> <span class="n">face_indices</span>
            
            <span class="c1">#create a trimesh submshesh</span>
            
            <span class="n">branches_submeshes_apical</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">total_indices</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#return branches_submeshes_apical</span>
        
        <span class="c1">#iterate through meshes and assign certain labels to these guys</span>
        
        
        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span><span class="n">submesh</span> <span class="ow">in</span> <span class="n">branches_submeshes_apical</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            
            <span class="c1">#get the number of faces</span>
            <span class="n">total_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">submesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="c1">#print(f&quot;total_faces  = {total_faces}&quot;)</span>
            
            <span class="k">if</span> <span class="n">total_faces</span> <span class="o">&lt;</span> <span class="n">classifier_stub_threshold_apical</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2"> = stub apical&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">apical_branches</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    
                    <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;apical&quot;</span>
            <span class="k">else</span><span class="p">:</span>
            
                <span class="n">mean_convex</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">convex</span><span class="o">.</span><span class="n">adjacency_projections</span><span class="p">(</span><span class="n">submesh</span><span class="p">)))</span>
                <span class="c1">#print(f&quot;total_faces  = {mean_convex}&quot;)</span>
                <span class="k">if</span> <span class="n">mean_convex</span> <span class="o">&gt;</span> <span class="n">non_dendrite_convex_threshold</span><span class="p">:</span>
                    <span class="c1">#classify according to size</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2"> = error&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">apical_branches</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                        <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#try to see if there is any axon like objects off of apical --&gt; if so then error</span>
                    <span class="c1">#calculate the standard deviation</span>
                    <span class="n">std_dev_convex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">((</span><span class="n">trimesh</span><span class="o">.</span><span class="n">convex</span><span class="o">.</span><span class="n">adjacency_projections</span><span class="p">(</span><span class="n">submesh</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="n">std_dev_convex</span> <span class="o">&lt;</span> <span class="n">classifier_axon_std_dev_threshold</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">apical_branches</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                            <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span>


        <span class="k">for</span> <span class="n">label_name</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">shortest_paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">label_name</span> <span class="o">==</span> <span class="n">possible_Apical</span><span class="p">:</span> <span class="c1">#labels the possible apical as apical</span>
                <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">label_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;apical&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">possible_Apical</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                    <span class="c1">#if has apical on path and not the apical itself, soma or other label --&gt; label oblique</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span> 
                        <span class="k">if</span> <span class="n">jj</span> <span class="o">!=</span> <span class="n">possible_Apical</span> <span class="ow">and</span> <span class="n">jj</span> <span class="o">!=</span> <span class="n">soma_index</span> <span class="ow">and</span> <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;unsure&quot;</span><span class="p">:</span>
                            <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;oblique&quot;</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#if NO apical on path and not the apical itself, soma or other label --&gt; label oblique</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">jj</span> <span class="o">!=</span> <span class="n">possible_Apical</span> <span class="ow">and</span> <span class="n">jj</span> <span class="o">!=</span> <span class="n">soma_index</span> <span class="ow">and</span> <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;unsure&quot;</span><span class="p">:</span>
                            <span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;basal&quot;</span> 

        <span class="c1">#return the final list of labels:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whole_neuron_labels</span> <span class="o">=</span> <span class="n">whole_neuron_labels</span>
        <span class="k">return</span></div>
    
    <span class="c1">#Step 7</span>
<div class="viewcode-block" id="WholeNeuronClassifier.label_whole_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.label_whole_neuron">[docs]</a>    <span class="k">def</span> <span class="nf">label_whole_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        iterates through all of faces and labels them accoring</span>
<span class="sd">        to the labels assigned to the cgal generic labels</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#instead of going to datajoint for labels</span>
        <span class="c1">#this just have it locally so don&#39;t rely on datajoint</span>

        <span class="n">apical_index</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">basal_index</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">oblique_index</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">soma_index</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">cilia_index</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="n">error_index</span> <span class="o">=</span> <span class="mi">10</span> 
        <span class="n">axon_index</span><span class="o">=</span><span class="mi">6</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
        

        <span class="n">unknown_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">lab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_list</span><span class="p">):</span>
            <span class="c1">#get the category according to the dictionary</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whole_neuron_labels</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;apical&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">apical_index</span>
            <span class="k">elif</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;basal&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">basal_index</span>
            <span class="k">elif</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;oblique&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">oblique_index</span>
            <span class="k">elif</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;soma&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_index</span>
            <span class="k">elif</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;cilia&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cilia_index</span>
            <span class="k">elif</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">axon_index</span>
            <span class="k">elif</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;error&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#if wasn&#39;t labeled anything just assing it a random color based on cgal assignment</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">18</span> <span class="o">+</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">lab</span><span class="p">))</span></div>

        
<div class="viewcode-block" id="WholeNeuronClassifier.generate_output_lists"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.generate_output_lists">[docs]</a>    <span class="k">def</span> <span class="nf">generate_output_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Will generate the final faces and vertices labels for the classification</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">output_faces_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span>
        

        <span class="c1">#generate the vertices labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_verts_to_face_dictionary</span><span class="p">(</span><span class="n">output_faces_list</span><span class="p">)</span>

        <span class="n">output_verts_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verts_to_Label</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">verts_to_Label</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output_verts_labels_list</span> <span class="o">=</span> <span class="n">output_verts_list</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_verts_labels_list</span> </div>
    


<div class="viewcode-block" id="WholeNeuronClassifier.return_branches"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.return_branches">[docs]</a>    <span class="k">def</span> <span class="nf">return_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">return_cilia</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_soma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_error</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">,</span><span class="n">return_size_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
        <span class="n">all_components</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">apical_index</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">basal_index</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">oblique_index</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">soma_index</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">cilia_index</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="n">error_index</span> <span class="o">=</span> <span class="mi">10</span> 
        <span class="n">axon_index</span><span class="o">=</span><span class="mi">6</span>
        
        <span class="n">basal_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span> <span class="o">==</span> <span class="n">basal_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">oblique_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span> <span class="o">==</span> <span class="n">oblique_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">apical_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span> <span class="o">==</span> <span class="n">apical_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#axon_indexes = np.where(self.final_faces_labels_list == axon_index)</span>
        <span class="n">spine_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">basal_indexes</span><span class="p">,</span><span class="n">oblique_indexes</span><span class="p">,</span><span class="n">apical_indexes</span><span class="p">])]</span>
        
        <span class="k">if</span> <span class="n">spine_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#gets all of the dendritic branches</span>
            <span class="n">spine_meshes_whole</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">spine_indexes</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">split_up_spines</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1">#decides if passing back spines as one whole mesh or seperate meshes</span>
            <span class="k">if</span> <span class="n">split_up_spines</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="n">individual_spines</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">temp_spines</span> <span class="o">=</span> <span class="n">spine_meshes_whole</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="n">temp_spines</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">return_size_threshold</span><span class="p">:</span>
                        <span class="n">individual_spines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">individual_spines</span> <span class="o">=</span> <span class="n">spine_meshes_whole</span>
                    
        <span class="k">else</span><span class="p">:</span>
            
            <span class="n">individual_spines</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">individual_spines</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">individual_spines</span> <span class="o">=</span> <span class="kc">None</span>
        
        
        <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;dendrites&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">individual_spines</span>
        
        
        <span class="c1">#will also pass back the cilia,axon or soma based on the parameters of the mesh with the extracted spines</span>
        <span class="k">if</span> <span class="n">return_cilia</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">shaft_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">cilia_index</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">shaft_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">shaft_mesh_whole</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">shaft_indexes</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;cilia&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shaft_mesh_whole</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;cilia&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1">#will also pass back the cilia,axon or soma based on the parameters of the mesh with the extracted spines</span>
        <span class="k">if</span> <span class="n">return_soma</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">shaft_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">soma_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shaft_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">shaft_mesh_whole</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">shaft_indexes</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;soma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shaft_mesh_whole</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;soma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="c1">#will also pass back the cilia,axon or soma based on the parameters of the mesh with the extracted spines</span>
        <span class="k">if</span> <span class="n">return_axon</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">shaft_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">axon_index</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">shaft_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">shaft_mesh_whole</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">shaft_indexes</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shaft_mesh_whole</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        
        <span class="k">if</span> <span class="n">return_error</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">shaft_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_faces_labels_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">error_index</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">shaft_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#gets all of the dendritic branches</span>
                <span class="n">spine_meshes_whole</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">(</span><span class="n">shaft_indexes</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">split_up_spines</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1">#decides if passing back spines as one whole mesh or seperate meshes</span>
                <span class="k">if</span> <span class="n">split_up_spines</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                    <span class="n">individual_error</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">temp_spines</span> <span class="o">=</span> <span class="n">spine_meshes_whole</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="n">temp_spines</span><span class="p">:</span>
                        <span class="n">individual_error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">individual_error</span> <span class="o">=</span> <span class="n">spine_meshes_whole</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">individual_error</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">individual_error</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">individual_error</span> <span class="o">=</span> <span class="kc">None</span>
        
        
            <span class="n">all_components</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">individual_error</span>
        
        <span class="k">return</span> <span class="n">all_components</span></div>
            

<div class="viewcode-block" id="WholeNeuronClassifier.clean_files"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.WholeNeuronClassifier.clean_files">[docs]</a>    <span class="k">def</span> <span class="nf">clean_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#clean the files </span>
        
        <span class="c1">#1) new mesh file</span>
        <span class="c1">#2) cgal files (sdf and labels)</span>
        
        <span class="n">files_to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_fixed&quot;</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">labels_file</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_revised.csv&quot;</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">labels_file</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">sdf_file</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">myfile</span> <span class="ow">in</span> <span class="n">files_to_delete</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">myfile</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">myfile</span><span class="p">)</span>

        
        <span class="k">return</span></div></div>
        
        
        
<div class="viewcode-block" id="extract_branches_whole_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.whole_neuron_classifier_datajoint_adapted.extract_branches_whole_neuron">[docs]</a><span class="k">def</span> <span class="nf">extract_branches_whole_neuron</span><span class="p">(</span><span class="n">import_Off_Flag</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the meshes of all dendritic branches (optionally soma, axon, cilia meshes)</span>
<span class="sd">    from a full neuron mesh  (Assumes meshes have been decimated to 35% original size but if not then scaling </span>
<span class="sd">    can be adjusted using size_multiplier argument)</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    mesh_file_location (str): location of the dendritic mesh on computer</span>
<span class="sd">    file_name (str): file name of dendritic mesh on computer</span>
<span class="sd">    size_multiplier (float): multiplying factor to help scale all size thresholds in case of up/downsampling of faces (default = 1)</span>
<span class="sd">    </span>
<span class="sd">        Option kwargs parameters</span>
<span class="sd">        </span>
<span class="sd">    --- Step 1: Mesh importing and Pymeshfix parameters ---</span>
<span class="sd">    </span>
<span class="sd">    joincomp : bool, optional (default = True)</span>
<span class="sd">       Attempts to join nearby open components.</span>

<span class="sd">    remove_smallest_components : bool, optional (default = False)</span>
<span class="sd">        Remove all but the largest isolated component from the mesh</span>
<span class="sd">        before beginning the repair process.  Default True</span>
<span class="sd">        </span>
<span class="sd">    --- Step 2: CGAL segmentation parameters ---</span>

<span class="sd">    clusters (int) : number of clusters to use for CGAL surface mesh segmentation (default = 4)</span>
<span class="sd">    smoothness (int) : smoothness parameter use for CGAL surface mesh segmentation (default = 0.30)</span>
<span class="sd">    </span>
<span class="sd">    --- Step 3: Soma identification parameters ---</span>
<span class="sd">    </span>
<span class="sd">    soma_size_threshold (int) : Minimum number of faces (multiplied by size_multipler) of segment to be classified as soma (default = 3000)</span>
<span class="sd">    </span>
<span class="sd">    --- Step 4: Findin Soma extensions parameters --- </span>
<span class="sd">    #if clusters &gt; 3, then will try to relabel small stubs off of soma as soma (helps with identifying axons)</span>
<span class="sd">    soma_cap_min_width (float): Minimum width size to be categorized as soma extension (default = 0.23) </span>
<span class="sd">    soma_cap_max_faces (int): Maximum number of faces (multiplied by size_multipler) to be categorized as soma extension (default = 6000)</span>
<span class="sd">    soma_cap_max_n_connections (int): Maximum number of neighbors to be considered soma extension(default = 6)</span>
<span class="sd">    large_extension_size (int): Maximum number of faces (multiplied by size_multipler) to be considered a possible large soma extension segment</span>
<span class="sd">    large_extension_convex_max (float): Maximum value for the mean of the convex adjacency projections for large segments to be considered soma extension (default = 3.0) </span>
<span class="sd">    </span>
<span class="sd">    --- Step 5: Apical Identifying Parameters --- </span>
<span class="sd">    apical_mesh_threshold (int) : Minimum size of segment (multiplied by size_multipler) to be considered possible apical (default = 2000)</span>
<span class="sd">    apical_height_threshold (int) : Minimum height of bounding box of segment to be considered possible apical (default = 5000) </span>
<span class="sd">    apical_sdf_threshold (float) : Minimum width of segment to be considered possible apical (default = 0.09)</span>
<span class="sd">    </span>
<span class="sd">    --- Step 6: Classifying Entire Mesh Parameters ---</span>
<span class="sd">    classifier_cilia_threshold (int): Maximum size of segment (multiplied by size_multipler) to be considered possible cilia (default = 1000) </span>
<span class="sd">    classifier_stub_threshold (int): minimum size of appndage of soma (multiplied by size_multipler) to not be considered stub and merged with the soma (default = 200) </span>
<span class="sd">    classifier_non_dendrite_convex_threshold (float) : Segment must be above this mean convex value to be considered a possible axon, cilia or error(default = 26.5) </span>
<span class="sd">    classifier_axon_std_dev_threshold (float): standard deviation of convex measurements for which axon branches are under this threshold (default = 69.0) </span>
<span class="sd">    classifier_stub_threshold_apical (int) = the minimum size threshold (multiplied by size_multipler) for apical appendage not to be merged with apical(default = 700) </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    ---Step 9: Output Configuration Parameters ---</span>
<span class="sd">    if return_Only_Labels is set to true then will only return the vertex_labels,face_labels</span>
<span class="sd">    </span>
<span class="sd">    * if any of the below settings are set to true then will return a dictionary storing </span>
<span class="sd">    the lists for each mesh category (dendrite,cilia,soma,axon) only for those present that flag is set True</span>
<span class="sd">    The dendritic branches will always be returned</span>
<span class="sd">    </span>
<span class="sd">    return_cilia (bool) : if true will return cilia mesh inside returned dictionary (default = False)</span>
<span class="sd">    return_soma (bool) : if true will return soma mesh inside returned dictionary (default = False)</span>
<span class="sd">    return_axon (bool) : if true will return axon mesh inside returned dictionary (default = False)</span>
<span class="sd">    return_error (bool) : if true will return error mesh inside returned dictionary (default = False)</span>
<span class="sd">    return_size_threshold (int): Minimum size (multiplied by size_multipler) of dendrite piece to be returned (default = 200)</span>
<span class="sd">    </span>
<span class="sd">    --- Step 10: Cleaning up temporary files parameters ---</span>
<span class="sd">    clean_temp_files (bool) : if true, will delete all the temporary segmentation and pymeshfix files (default = True)</span>
<span class="sd">    </span>
<span class="sd">        -------------------------------------</span>
<span class="sd">  </span>
<span class="sd">    Returns: </span>
<span class="sd">    if return_cilia,return_soma,return_axon,return_error are all set to false: </span>
<span class="sd">        return  lists of trimesh.mesh/None based on the number of dendrite branches found</span>
<span class="sd">    if Any of the return_cilia,return_soma,return_axon,return_error are set to true: </span>
<span class="sd">        returns dictionary containing 4 keys: dendrites,soma,cilia,axon</span>
<span class="sd">        For each value will return  lists of object (for dendrtiess), trimesh.mesh objects (for other compartments) or None based on the number of that compartment found</span>

<span class="sd">    Examples:</span>
<span class="sd">    #returns just simple list of dendrite meshes</span>
<span class="sd">    list_of_dendrite_meshes = extract_branches_whole_neuron(file_location,file_name)</span>
<span class="sd">    </span>
<span class="sd">    #returns dendrite meshes and an available soma mesh</span>
<span class="sd">    compartment_meshes= complete_spine_extraction(file_location,file_name,return_soma=True)</span>
<span class="sd">    soma_mesh = compartment_meshes[&quot;soma&quot;]</span>
<span class="sd">    dendrite_mesh_list = compartment_meshes[&quot;dendrites&quot;]</span>
<span class="sd">    </span>
<span class="sd">    #retruns dendrite meshes but adjusts for not downsampling meshes to 35% original as default settings assume</span>
<span class="sd">    list_of_dendrite_meshes = extract_branches_whole_neuron(file_location,file_name,size_multiplier=1/0.35)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    

    
    <span class="n">global_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
   
    <span class="c1"># Step 0: Where to import from and whether to only extract the soma</span>
    
    <span class="c1">#if import_Off_Flag == True:</span>
    <span class="c1">#if loading from an off file</span>
    <span class="n">soma_only</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;soma_only&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">return_classifier</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;return_classifier&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">mesh_file_location</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mesh_file_location&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;file_name&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="c1">#else:</span>
    <span class="c1">#if loading from datajoint</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">triangles</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;triangles&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">segment_id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;segment_id&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="c1">#Step 1: Mesh importing and Pymeshfix parameters</span>
    <span class="n">pymeshfix_Flag</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pymeshfix_Flag&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="n">joincomp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;joincomp&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">remove_smallest_components</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;remove_smallest_components&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1">#Step 2: CGAL segmentation parameters</span>
    
    <span class="n">import_CGAL_Flag</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;import_CGAL_Flag&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">import_CGAL_paths</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;import_CGAL_paths&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;&quot;</span><span class="p">],[</span><span class="s2">&quot;&quot;</span><span class="p">]])</span>
    
    <span class="n">clusters</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;clusters&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">smoothness</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;smoothness&#39;</span><span class="p">,</span> <span class="mf">0.30</span><span class="p">)</span>
    
    <span class="c1">#step 3: Soma identification parameters</span>
    <span class="n">size_multiplier</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;size_multiplier&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;soma_size_threshold&quot;</span><span class="p">,</span><span class="mi">3000</span><span class="p">)</span>
    
    <span class="c1">#step 4: finding soma extensions parameters</span>
    <span class="n">soma_cap_min_width</span><span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;soma_cap_min_width&#39;</span><span class="p">,</span> <span class="mf">0.23</span><span class="p">)</span> 
    <span class="n">soma_cap_max_faces</span><span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;soma_cap_max_faces&#39;</span><span class="p">,</span> <span class="mi">6000</span><span class="p">)</span> 
    <span class="n">soma_cap_max_n_connections</span><span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;soma_cap_max_n_connections&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> 
    <span class="n">large_extension_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;large_extension_size&#39;</span><span class="p">,</span> <span class="mi">1500</span><span class="p">)</span> 
    <span class="n">large_extension_convex_max</span><span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;soma_cap_conex_threshold&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> 
    
    
    
    <span class="c1">#Step 5: Apical Identifying Parameters</span>
    <span class="n">apical_mesh_threshold</span><span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;apical_mesh_threshold&#39;</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
    <span class="n">apical_height_threshold</span><span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;apical_height_threshold&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span> 
    <span class="n">apical_sdf_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;apical_sdf_threshold&#39;</span><span class="p">,</span> <span class="mf">0.09</span><span class="p">)</span>
    
    <span class="c1">#Step 6: Classifying Entire Mesh parameters</span>
    <span class="n">classifier_cilia_threshold</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;classifier_cilia_threshold&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c1">#maximum size of cilia</span>
    <span class="n">classifier_stub_threshold</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;classifier_stub_threshold&#39;</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="c1"># minimum size of appndage of soma to not be considered stub and merged with the soma</span>
    <span class="n">classifier_non_dendrite_convex_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;classifier_non_dendrite_convex_threshold&#39;</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">)</span> <span class="c1">#must be above this value to be axon, cilia or error</span>
    <span class="n">classifier_axon_std_dev_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;classifier_axon_std_dev_threshold&#39;</span><span class="p">,</span> <span class="mi">69</span><span class="p">)</span> <span class="c1">#standard deviation of convex measurements for which axon branches are under this threshold</span>
    <span class="n">classifier_stub_threshold_apical</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;classifier_stub_threshold_apical&#39;</span><span class="p">,</span> <span class="mi">700</span><span class="p">)</span> <span class="c1">#the minimum size threshold for apical appendage not to be merged with apical</span>
    
    <span class="c1">#Step 9: Output Configuration Parameters</span>
    <span class="n">return_Only_Labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;return_Only_Labels&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">return_cilia</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return_cilia&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">return_soma</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return_soma&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">return_axon</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return_axon&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">return_error</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return_error&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">return_size_threshold</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;return_size_threshold&#39;</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    
    <span class="n">clean_temp_files</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;clean_temp_files&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    
    
    
    <span class="c1">#making sure there is no more keyword arguments left that you weren&#39;t expecting</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unexpected **kwargs: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>
    

    
    <span class="c1">#check to see if file exists and if it is an off file</span>
    <span class="k">if</span> <span class="n">import_Off_Flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">file_name</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input file must be a .off &quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">mesh_file_location</span><span class="p">)</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_name</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">mesh_file_location</span><span class="p">)</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; cannot be found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
    


    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1) Starting: Mesh importing and Pymesh fix&quot;</span><span class="p">)</span>
    <span class="n">classifier</span> <span class="o">=</span> <span class="n">WholeNeuronClassifier</span><span class="p">(</span><span class="n">mesh_file_location</span><span class="p">,</span><span class="n">file_name</span><span class="p">,</span><span class="n">import_Off_Flag</span><span class="p">,</span><span class="n">pymeshfix_Flag</span><span class="p">,</span><span class="n">joincomp</span><span class="p">,</span><span class="n">remove_smallest_components</span><span class="p">,</span>
                                      <span class="n">vertices</span><span class="p">,</span><span class="n">triangles</span><span class="p">,</span><span class="n">segment_id</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1) Finished: Mesh importing and Pymesh fix: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2) Staring: Generating CGAL segmentation for neuron&quot;</span><span class="p">)</span>
    <span class="n">classifier</span><span class="o">.</span><span class="n">load_cgal_segmentation</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="n">smoothness</span><span class="p">,</span><span class="n">import_CGAL_Flag</span><span class="p">,</span><span class="n">import_CGAL_paths</span><span class="p">)</span>
    <span class="c1">#retrieves the cgal data from the file</span>
    

    <span class="c1">#check to see if files exist</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="n">classifier</span><span class="o">.</span><span class="n">labels_file</span><span class="p">,</span><span class="n">classifier</span><span class="o">.</span><span class="n">sdf_file</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CGAL segmentation files weren&#39;t generated&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;CGAL segmentation files weren&#39;t generated&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="s2">&quot;Failure&quot;</span>
    
    <span class="n">classifier</span><span class="o">.</span><span class="n">get_cgal_data_and_label_local_optomized</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2) Finished: Generating CGAL segmentation for neuron: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    

    <span class="c1">#get the highest values of sdf</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3) Staring: Generating Graph Structure and Identifying Soma using soma size threshold  = </span><span class="si">{</span><span class="n">size_multiplier</span><span class="o">*</span><span class="n">soma_size_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">soma_index</span><span class="p">,</span><span class="n">soma_sdf_value</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">get_highest_sdf_part</span><span class="p">(</span><span class="n">size_multiplier</span><span class="o">*</span><span class="n">soma_size_threshold</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_index = </span><span class="si">{</span><span class="n">soma_index</span><span class="si">}</span><span class="s2">, soma_sdf_value = </span><span class="si">{</span><span class="n">soma_sdf_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#create a graph structure and stats for the whole neuron</span>
    <span class="n">classifier</span><span class="o">.</span><span class="n">get_graph_structure</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3) Finished: Generating Graph Structure and Identifying Soma: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#gets the caps of the somas created from segmenting into 4 clusters</span>
    <span class="k">if</span> <span class="n">clusters</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4) Staring: Finding Soma Extensions&quot;</span><span class="p">)</span>
        <span class="n">classifier</span><span class="o">.</span><span class="n">find_Soma_Caps</span><span class="p">(</span><span class="n">soma_index</span><span class="p">,</span><span class="n">soma_cap_min_width</span><span class="p">,</span>
                                  <span class="n">soma_cap_max_faces</span><span class="o">*</span><span class="n">size_multiplier</span><span class="p">,</span>
                                  <span class="n">soma_cap_max_n_connections</span><span class="p">,</span>
                                  <span class="n">large_extension_size</span><span class="o">=</span><span class="n">large_extension_size</span><span class="o">*</span><span class="n">size_multiplier</span><span class="p">,</span>
                                  <span class="n">large_extension_convex_max</span><span class="o">=</span><span class="n">large_extension_convex_max</span>
                                 <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;4) Finished: Finding Soma Extensions: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">soma_only</span><span class="p">:</span>
    
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;5) Staring: Finding Apical Index&quot;</span><span class="p">)</span>
        <span class="c1">#send data to function that will find the Apical</span>
        <span class="n">possible_Apical</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">find_Apical</span><span class="p">(</span><span class="n">soma_index</span><span class="p">,</span><span class="n">apical_mesh_threshold</span><span class="o">*</span><span class="n">size_multiplier</span><span class="p">,</span>
                                                <span class="n">apical_height_threshold</span><span class="p">,</span>
                                                <span class="n">apical_sdf_threshold</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;possible_Apical = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">possible_Apical</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;5) Finished: Finding Apical Index: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not finding the apical because soma_only option selected&quot;</span><span class="p">)</span>
        <span class="n">possible_Apical</span><span class="o">=</span><span class="kc">None</span>
        

    <span class="c1">#use the apical label and the soma label to classify the rest as basal or oblique and return a dictionary that has the mapping of label to compartment type</span>
    <span class="c1">#but only classifies the cgal labels and not each individual face</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;6) Staring: Classifying Entire Neuron&quot;</span><span class="p">)</span>
    <span class="n">classifier</span><span class="o">.</span><span class="n">classify_whole_neuron</span><span class="p">(</span><span class="n">possible_Apical</span><span class="p">,</span><span class="n">soma_index</span><span class="p">,</span>
                                                <span class="n">classifier_cilia_threshold</span><span class="o">*</span><span class="n">size_multiplier</span><span class="p">,</span>
                                                <span class="n">classifier_stub_threshold</span><span class="o">*</span><span class="n">size_multiplier</span><span class="p">,</span>
                                                <span class="n">classifier_non_dendrite_convex_threshold</span><span class="p">,</span>
                                                <span class="n">classifier_axon_std_dev_threshold</span><span class="p">,</span>
                                                <span class="n">classifier_stub_threshold_apical</span><span class="o">*</span><span class="n">size_multiplier</span><span class="p">,</span>
                                     <span class="n">soma_only</span><span class="o">=</span><span class="n">soma_only</span>
                                               <span class="p">)</span>
    
    <span class="c1">#print unique list of labels found</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total Labels found = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">classifier</span><span class="o">.</span><span class="n">whole_neuron_labels</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;6) Finished: Classifying Entire Neuron: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#label the neurons according to classification</span>
    <span class="c1">#############NEED TO ADD STEP THAT CALCULATES THE LABELS OF THE VERTICES ##################</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;7) Staring: Transfering Segmentation Labels to Face Labels&quot;</span><span class="p">)</span>
    <span class="n">classifier</span><span class="o">.</span><span class="n">label_whole_neuron</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;7) Finished: Transfering Segmentation Labels to Face Labels: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="c1">#####need to map the final_faces_labels_list to all successive numbers and get vertices</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;8) Staring: Generating final Vertex and Face Labels&quot;</span><span class="p">)</span>
    <span class="n">output_faces_list</span><span class="p">,</span> <span class="n">output_verts_list</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">generate_output_lists</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;8) Finished: Generating final Vertex and Face Labels: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_Only_Labels</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">soma_only</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_classifier</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Returning the soma_sdf value AND the classifier&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">output_verts_list</span><span class="p">,</span> <span class="n">output_faces_list</span><span class="p">,</span><span class="n">soma_sdf_value</span><span class="p">,</span><span class="n">classifier</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Returning the soma_sdf value&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">output_verts_list</span><span class="p">,</span> <span class="n">output_faces_list</span><span class="p">,</span><span class="n">soma_sdf_value</span>
        <span class="k">elif</span> <span class="n">return_classifier</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_verts_list</span><span class="p">,</span> <span class="n">output_faces_list</span><span class="p">,</span> <span class="n">classifier</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_verts_list</span><span class="p">,</span> <span class="n">output_faces_list</span>
    
    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;9) Staring: Generating Returning Branches&quot;</span><span class="p">)</span>
    <span class="n">dendritic_branches</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">return_branches</span><span class="p">(</span><span class="n">return_cilia</span><span class="p">,</span>
                                                    <span class="n">return_soma</span><span class="p">,</span>
                                                    <span class="n">return_axon</span><span class="p">,</span>
                                                    <span class="n">return_error</span><span class="p">,</span>
                                                    <span class="n">return_size_threshold</span><span class="o">*</span><span class="n">size_multiplier</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;9) Finished: Generating Returning Branches: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="n">dendrites_segments</span> <span class="o">=</span> <span class="n">dendritic_branches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;dendrites&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">cilia_segments</span> <span class="o">=</span> <span class="n">dendritic_branches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cilia&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">soma_segments</span> <span class="o">=</span> <span class="n">dendritic_branches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;soma&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">axon_segments</span> <span class="o">=</span> <span class="n">dendritic_branches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">error_segments</span> <span class="o">=</span> <span class="n">dendritic_branches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                                      
    <span class="n">size_one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="k">if</span> <span class="n">dendrites_segments</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dendrites_number</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dendrites_segments</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">size_one</span><span class="p">:</span>
        <span class="n">dendrites_number</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dendrites_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dendrites_segments</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning: </span><span class="se">\n</span><span class="si">{</span><span class="n">dendrites_number</span><span class="si">}</span><span class="s2"> dendritic branches&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_cilia</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cilia_segments</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cilia_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cilia_segments</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">size_one</span><span class="p">:</span>
            <span class="n">cilia_number</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cilia_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cilia_segments</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">cilia_number</span><span class="si">}</span><span class="s2"> cilia&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_soma</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">soma_segments</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">soma_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">soma_segments</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">size_one</span><span class="p">:</span>
            <span class="n">soma_number</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">soma_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_segments</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">soma_number</span><span class="si">}</span><span class="s2"> soma&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_axon</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axon_segments</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axon_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axon_segments</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">size_one</span><span class="p">:</span>
            <span class="n">axon_number</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axon_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_segments</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">axon_number</span><span class="si">}</span><span class="s2"> axon&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_error</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">error_segments</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error_segments</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">size_one</span><span class="p">:</span>
            <span class="n">axon_number</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_segments</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">error_number</span><span class="si">}</span><span class="s2"> errors&quot;</span><span class="p">)</span>
    
          
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">dendritic_branches</span><span class="p">[</span><span class="s2">&quot;dendrites&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">dendrites_segments</span>
    <span class="n">dendritic_branches</span><span class="p">[</span><span class="s2">&quot;cilia&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">cilia_segments</span>
    <span class="n">dendritic_branches</span><span class="p">[</span><span class="s2">&quot;soma&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">soma_segments</span>
    <span class="n">dendritic_branches</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">axon_segments</span>
    <span class="n">dendritic_branches</span><span class="p">[</span><span class="s2">&quot;error&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">error_segments</span>

    <span class="k">if</span> <span class="n">clean_temp_files</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">classifier</span><span class="o">.</span><span class="n">clean_files</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">return_cilia</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">return_soma</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">return_axon</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">return_error</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">dendritic_branches</span><span class="p">[</span><span class="s2">&quot;dendrites&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">dendritic_branches</span></div>

<span class="w">        </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">New additions adding: </span>
<span class="sd">1) Can take in arrays of vertices and triangles instead of an off file: Done</span>
<span class="sd">2) Can take in optional argument to load CGAL data with the path to it: Done</span>
<span class="sd">3) Made pymeshfix optional: Done</span>
<span class="sd">4) Added option where can skip the outputting in trimesh objects and will just output the vertice and face labels</span>
<span class="sd">    using the return_Only_Labels flag</span>

<span class="sd">Need to investigate what these guys are also used for: </span>
<span class="sd">self.mesh_file_location = mesh_file_location --&gt; doesn&#39;t do anything else</span>
<span class="sd">self.file_name = file_name</span>
<span class="sd">    </span>




<span class="sd">&quot;&quot;&quot;</span>


<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>