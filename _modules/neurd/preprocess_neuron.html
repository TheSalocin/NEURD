<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.preprocess_neuron &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.preprocess_neuron</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.preprocess_neuron</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">reload</span>
<span class="kn">from</span> <span class="nn">meshparty</span> <span class="kn">import</span> <span class="n">trimesh_io</span>


<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>

<span class="c1">#importing at the bottom so don&#39;t get any conflicts</span>

<span class="c1">#for meshparty preprocessing</span>

<span class="c1">#from neuron_utils import *</span>




<div class="viewcode-block" id="further_mesh_correspondence_processing_from_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.further_mesh_correspondence_processing_from_skeleton">[docs]</a><span class="k">def</span> <span class="nf">further_mesh_correspondence_processing_from_skeleton</span><span class="p">(</span><span class="n">soma_touching_mesh_data</span><span class="p">,</span>        
                                                        <span class="n">combine_close_skeleton_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span>
                                                         <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">branch_skeleton_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                        <span class="n">soma_to_piece_touching_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                        <span class="n">endpoints_must_keep</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="n">current_mesh_data</span> <span class="o">=</span> <span class="n">soma_touching_mesh_data</span>



    <span class="c1"># *************** Phase B *****************</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\n\n\n</span><span class="s2">****** Phase B ***************</span><span class="se">\n\n\n\n\n</span><span class="s2">&quot;</span><span class="p">)</span>




    <span class="c1"># visualizing the original neuron</span>
<span class="c1">#     current_neuron = trimesh.load_mesh(current_mesh_file)</span>
<span class="c1">#     sk.graph_skeleton_and_mesh(main_mesh_verts=current_neuron.vertices,</span>
<span class="c1">#                               main_mesh_faces=current_neuron.faces,</span>
<span class="c1">#                                main_mesh_color = [0.,1.,0.,0.8]</span>
<span class="c1">#                               )</span>


    <span class="c1"># visualizing the somas that were extracted</span>
<span class="c1">#     soma_meshes = tu.combine_meshes(current_mesh_data[0][&quot;soma_meshes&quot;])</span>
<span class="c1">#     sk.graph_skeleton_and_mesh(main_mesh_verts=soma_meshes.vertices,</span>
<span class="c1">#                               main_mesh_faces=soma_meshes.faces,</span>
<span class="c1">#                                main_mesh_color = [0.,1.,0.,0.8]</span>
<span class="c1">#                               )</span>


    <span class="c1"># # Visualize the extracted branches</span>
    <span class="c1"># # visualize all of the branches and the meshes</span>
    <span class="c1"># sk.graph_skeleton_and_mesh(other_meshes=list(current_mesh_data[0][&quot;branch_meshes&quot;]) + list(current_mesh_data[0][&quot;soma_meshes&quot;]),</span>
    <span class="c1">#                           other_meshes_colors=&quot;random&quot;,</span>
    <span class="c1">#                            other_skeletons = current_mesh_data[0][&quot;branch_skeletons&quot;],</span>
    <span class="c1">#                           other_skeletons_colors=&quot;random&quot;)</span>








    <span class="c1">#--- 1) Cleaning each limb through distance and decomposition, checking that all cleaned branches are connected components and then visualizing</span>

    
    <span class="k">if</span> <span class="n">branch_skeleton_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">total_cleaned</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_skeleton_to_clean</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons&quot;</span><span class="p">]):</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---- Working on Limb </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> ----&quot;</span><span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;before cleaning limb size of skeleton = </span><span class="si">{</span><span class="n">curr_skeleton_to_clean</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
<span class="c1">#             &quot;&quot;&quot; 9/16 Edit: Now send the border vertices and don&#39;t want to clean anyy end nodes that are within certain distance of border&quot;&quot;&quot;</span>
<span class="c1">#             *** WE DIDN&#39;T END UP NEEDING TO DO THE SKELETON CLEANING AGAIN BECAUSE ALREADY RAN IT</span>
<span class="c1">#             if not soma_to_piece_touching_vertices is None:</span>
<span class="c1">#                 total_border_vertices = []</span>
<span class="c1">#                 for k in soma_to_piece_touching_vertices.keys():</span>
<span class="c1">#                     if j in soma_to_piece_touching_vertices[k].keys():</span>
<span class="c1">#                         total_border_vertices.append(soma_to_piece_touching_vertices[k][j])</span>

<span class="c1">#                 if len(total_border_vertices) &gt; 0:</span>
<span class="c1">#                     total_border_vertices = np.concatenate(total_border_vertices)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 total_border_vertices=None</span>

            
<span class="c1">#             skelton_cleaning_threshold = 4001</span>
<span class="c1">#             distance_cleaned_skeleton = sk.clean_skeleton(</span>
<span class="c1">#                                                         curr_skeleton_to_clean,</span>
<span class="c1">#                                                         distance_func=sk.skeletal_distance,</span>
<span class="c1">#                                                         min_distance_to_junction = skelton_cleaning_threshold,</span>
<span class="c1">#                                                         soma_border_vertices = total_border_vertices,</span>
<span class="c1">#                                                         skeleton_mesh=current_mesh_data[0][&quot;branch_meshes&quot;][j],</span>
<span class="c1">#                                                         return_skeleton=True,</span>
                
<span class="c1">#                                                         print_flag=False)</span>
            
            <span class="n">distance_cleaned_skeleton</span> <span class="o">=</span> <span class="n">curr_skeleton_to_clean</span>
            
            <span class="c1">#make sure still connected componet</span>
            <span class="n">distance_cleaned_skeleton_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">distance_cleaned_skeleton</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">distance_cleaned_skeleton_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;distance_cleaned_skeleton </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> was not a single component: it was actually </span><span class="si">{</span><span class="n">distance_cleaned_skeleton_components</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;after DISTANCE cleaning limb size of skeleton = </span><span class="si">{</span><span class="n">distance_cleaned_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cleaned_branch</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">clean_skeleton_with_decompose</span><span class="p">(</span><span class="n">distance_cleaned_skeleton</span><span class="p">)</span>

            <span class="n">cleaned_branch_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">cleaned_branch_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cleaned_branch </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> was not a single component: it was actually </span><span class="si">{</span><span class="n">cleaned_branch_components</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>

            <span class="c1">#do the cleanin ghtat removes loops from branches</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After DECOMPOSITION cleaning limb size of skeleton = </span><span class="si">{</span><span class="n">cleaned_branch</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">total_cleaned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">)</span>

        <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_cleaned</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;****Skipping skeleton cleaning and USING THE PRE-COMPUTED SKELETONS ****&quot;</span><span class="p">)</span>
        <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">]</span> <span class="o">=</span><span class="n">branch_skeleton_data</span>

    
<span class="c1">#     sk_debug = True</span>
<span class="c1">#     if sk_debug:</span>
<span class="c1">#         from python_tools import system_utils as su</span>
<span class="c1">#         su.compressed_pickle(deepcopy(current_mesh_data[0][&quot;branch_skeletons_cleaned&quot;]),</span>
<span class="c1">#                             &quot;second_branch_skeletons_cleaned&quot;)</span>
    
    <span class="c1"># checking all cleaned branches are connected components</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">cl_sk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons&quot;</span><span class="p">]):</span> 
        <span class="n">n_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">cl_sk</span><span class="p">))</span> 
        <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original limb </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> was not a single component: it was actually </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">cl_sk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">]):</span> 
        <span class="n">n_components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">cl_sk</span><span class="p">))</span> 
        <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cleaned limb </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> was not a single component: it was actually </span><span class="si">{</span><span class="n">n_components</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>


    <span class="c1"># # visualize all of the branches and the meshes</span>
    <span class="c1"># sk.graph_skeleton_and_mesh(other_meshes=list(current_mesh_data[0][&quot;branch_meshes&quot;]) + list(current_mesh_data[0][&quot;soma_meshes&quot;]),</span>
    <span class="c1">#                           other_meshes_colors=&quot;random&quot;,</span>
    <span class="c1">#                            other_skeletons = current_mesh_data[0][&quot;branch_skeletons_cleaned&quot;],</span>
    <span class="c1">#                           other_skeletons_colors=&quot;random&quot;,</span>
    <span class="c1">#                           mesh_alpha=0.15,</span>
    <span class="c1">#                           html_path=f&quot;{segment_id}_limb_skeleton.html&quot;)</span>


    <span class="k">if</span> <span class="n">combine_close_skeleton_nodes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;********COMBINING CLOSE SKELETON NODES WITHIN </span><span class="si">{</span><span class="n">combine_close_skeleton_nodes_threshold</span><span class="si">}</span><span class="s2"> DISTANCE**********&quot;</span><span class="p">)</span>
        <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">combine_close_branch_points</span><span class="p">(</span><span class="n">curr_limb_sk</span><span class="p">,</span>
                                                            <span class="n">combine_threshold</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes_threshold</span><span class="p">,</span>
                                                            <span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">curr_limb_sk</span> <span class="ow">in</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">]]</span>

    
<span class="c1">#     if sk_debug:</span>
<span class="c1">#         from python_tools import system_utils as su</span>
<span class="c1">#         su.compressed_pickle(deepcopy(current_mesh_data[0][&quot;branch_skeletons_cleaned&quot;]),</span>
<span class="c1">#                             &quot;third_combining_skeleton_nodes&quot;)</span>
    
    <span class="n">save_clean_skeleton</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">save_clean_skeleton</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">],</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">)</span>





    <span class="c1"># --- 2) Decomposing of limbs into branches and finding mesh correspondence (using adaptive mesh correspondence followed by a water fill for conflict and empty faces), checking that it went well with no empty meshes and all connected component graph (even when downsampling the skeleton) when constructed from branches, plus visualization at end</span>



    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">limb_correspondence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">soma_containing_idx</span><span class="o">=</span> <span class="mi">0</span>

    

    <span class="k">for</span> <span class="n">soma_containing_idx</span> <span class="ow">in</span> <span class="n">current_mesh_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">curr_limb_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="n">soma_containing_idx</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb #</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">curr_limb_sk</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="n">soma_containing_idx</span><span class="p">][</span><span class="s2">&quot;branch_skeletons_cleaned&quot;</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span>
            <span class="n">curr_limb_branches_sk_uneven</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">curr_limb_sk</span><span class="p">)</span> <span class="c1">#the line that is decomposing to branches</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; 9/17 Edit: Want to Not do mesh adaptive correspondence on the &quot;&quot;&quot;</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_branch_sk</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_limb_branches_sk_uneven</span><span class="p">)):</span>
                <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">returned_data</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">mesh_correspondence_adaptive_distance</span><span class="p">(</span><span class="n">curr_branch_sk</span><span class="p">,</span>
                                                  <span class="n">curr_limb_mesh</span><span class="p">,</span>
                                                 <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                                                 <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">)</span>
                    <span class="n">curr_branch_face_correspondence</span><span class="p">,</span> <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">returned_data</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_branch_sk.shape = </span><span class="si">{</span><span class="n">curr_branch_sk</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s2">&quot;saved_skeleton_branch.npz&quot;</span><span class="p">,</span><span class="n">curr_branch_sk</span><span class="o">=</span><span class="n">curr_branch_sk</span><span class="p">)</span>
                    <span class="n">tu</span><span class="o">.</span><span class="n">write_neuron_off</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="s2">&quot;curr_limb_mesh.off&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;returned_data = </span><span class="si">{</span><span class="n">returned_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The output from mesh_correspondence_adaptive_distance was nothing: curr_branch_face_correspondence=</span><span class="si">{</span><span class="n">curr_branch_face_correspondence</span><span class="si">}</span><span class="s2">, width_from_skeleton=</span><span class="si">{</span><span class="n">width_from_skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch_face_correspondence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">curr_submesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_branch_face_correspondence</span><span class="p">)],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_submesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>

                <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_branch_sk</span>
                <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_submesh</span>
                <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;correspondence_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_branch_face_correspondence</span>
                <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width_from_skeleton</span>


    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for decomposition = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#couple of checks on how the decomposition went:  for each limb</span>
    <span class="c1">#1) if shapes of skeletons cleaned and divided match</span>
    <span class="c1">#2) if skeletons are only one component</span>
    <span class="c1">#3) if you downsample the skeletons then still only one component</span>
    <span class="c1">#4) if any empty meshes</span>

    <span class="n">empty_submeshes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">soma_containing_idx</span> <span class="ow">in</span> <span class="n">current_mesh_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">curr_limb_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="n">soma_containing_idx</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---- checking limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">---&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> decomposed into </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">])</span><span class="si">}</span><span class="s2"> branches&quot;</span><span class="p">)</span>

            <span class="c1">#get all of the skeletons and make sure that they from a connected component</span>
            <span class="n">divided_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]]</span>
            <span class="n">divided_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span>
                                            <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">divided_branches</span><span class="p">))</span>

            <span class="n">divided_skeleton_graph_recovered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">divided_skeleton_graph</span><span class="p">)</span>

            <span class="n">cleaned_limb_skeleton</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;branch_skeletons_cleaned&#39;</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;divided_skeleton_graph_recovered = </span><span class="si">{</span><span class="n">divided_skeleton_graph_recovered</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;current_mesh_data[0][&#39;branch_skeletons_cleaned&#39;].shape = </span><span class="si">{</span><span class="n">cleaned_limb_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">divided_skeleton_graph_recovered</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">cleaned_limb_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;****divided_skeleton_graph_recovered and cleaned_limb_skeleton shapes not match: &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">divided_skeleton_graph_recovered</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs. </span><span class="si">{</span><span class="n">cleaned_limb_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> *****&quot;</span><span class="p">)</span>


            <span class="c1">#check that it is all one component</span>
            <span class="n">divided_skeleton_graph_n_comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">divided_skeleton_graph</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of connected components in deocmposed recovered graph = </span><span class="si">{</span><span class="n">divided_skeleton_graph_n_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">cleaned_limb_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">cleaned_limb_skeleton</span><span class="p">)</span>
            <span class="n">cleaned_limb_skeleton_graph_n_comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">cleaned_limb_skeleton_graph</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of connected components in cleaned skeleton graph= </span><span class="si">{</span><span class="n">cleaned_limb_skeleton_graph_n_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">divided_skeleton_graph_n_comp</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">cleaned_limb_skeleton_graph_n_comp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;One of the decompose_skeletons or cleaned skeletons was not just one component : </span><span class="si">{</span><span class="n">divided_skeleton_graph_n_comp</span><span class="p">,</span><span class="n">cleaned_limb_skeleton_graph_n_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#check that when we downsample it is not one component:</span>
            <span class="n">curr_branch_meshes_downsampled</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">n_segments</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">divided_branches</span><span class="p">]</span>
            <span class="n">downsampled_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">curr_branch_meshes_downsampled</span><span class="p">)</span>
            <span class="n">curr_sk_graph_debug</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">downsampled_skeleton</span><span class="p">)</span>


            <span class="n">con_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_sk_graph_debug</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">con_comp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were more than 1 component when downsizing: </span><span class="si">{</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">con_comp</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The downsampled branches number of connected components = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">con_comp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">empty_submeshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span> <span class="o">=</span> <span class="n">j</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Empty submeshes = </span><span class="si">{</span><span class="n">empty_submeshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">empty_submeshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found empyt meshes after branch mesh correspondence: </span><span class="si">{</span><span class="n">empty_submeshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="c1"># from python_tools import matplotlib_utils as mu</span>

    <span class="c1"># sk.graph_skeleton_and_mesh(other_meshes=total_branch_meshes,</span>
    <span class="c1">#                           other_meshes_colors=&quot;random&quot;,</span>
    <span class="c1">#                            other_skeletons=total_branch_skeletons,</span>
    <span class="c1">#                            other_skeletons_colors=&quot;random&quot;</span>
    <span class="c1">#                           )</span>















    <span class="c1"># ---3) Finishing off the face correspondence so get 1-to-1 correspondence of mesh face to skeletal piece</span>

    <span class="c1">#--- this is the function that will clean up a limb piece so have 1-1 correspondence</span>

    <span class="c1">#things to prep for visualizing the axons</span>
<span class="c1">#     total_widths = []</span>
<span class="c1">#     total_branch_skeletons = []</span>
<span class="c1">#     total_branch_meshes = []</span>



    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">mesh_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1">#clear out the mesh correspondence if already in limb_correspondecne</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;branch_mesh&quot;</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;branch_face_idx&quot;</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span>
        <span class="c1">#geting the current limb mesh</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Working on limb_correspondence for #</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="c1">#counts the number of divided branches which should be the total number of labels</span>
        <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="n">soma_containing_idx</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span>

        <span class="c1">#set up the face dictionary</span>
        <span class="n">face_lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))])</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">branch_piece</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">curr_faces_corresponded</span> <span class="o">=</span> <span class="n">branch_piece</span><span class="p">[</span><span class="s2">&quot;correspondence_face_idx&quot;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curr_faces_corresponded</span><span class="p">:</span>
                <span class="n">face_lookup</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="n">original_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">face_lookup</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(original_labels),len(original_labels) = </span><span class="si">{</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">original_labels</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(original_labels) != len(no_missing_labels) for original_labels = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">,no_missing_labels = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There are some missing labels in the initial labeling&quot;</span><span class="p">)</span>



        <span class="c1">#here is where can call the function that resolves the face labels</span>
        <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">resolve_empty_conflicting_face_labels</span><span class="p">(</span>
                         <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="p">,</span>
                         <span class="n">face_lookup</span><span class="o">=</span><span class="n">face_lookup</span><span class="p">,</span>
                         <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span>
        <span class="p">)</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  9/17 Addition: Will make sure that the desired starting node is touching the soma border &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        For each soma it is touching</span>
<span class="sd">        0) Get the soma border</span>
<span class="sd">        1) Find the label_to_expand based on the starting coordinate</span>
<span class="sd">        a. Get the starting coordinate</span>
<span class="sd">        </span>
<span class="sd">        soma_to_piece_touching_vertices=None</span>
<span class="sd">        endpoints_must_keep</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">endpoints_must_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">soma_to_piece_touching_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sm</span><span class="p">,</span><span class="n">limb_list</span> <span class="ow">in</span> <span class="n">soma_to_piece_touching_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_list</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1">#0) Get the soma border</span>
                <span class="n">curr_soma_border</span> <span class="o">=</span> <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">sm</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span>
                <span class="c1">#1) Find the label_to_expand based on the starting coordinate</span>
                <span class="n">st_coord</span> <span class="o">=</span> <span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">sm</span><span class="p">]</span>
                <span class="n">divided_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]]</span>
                <span class="n">label_to_expand</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">divded_skeleton</span><span class="o">=</span><span class="n">divided_branches</span><span class="p">,</span>
                                                                                   <span class="n">current_coordinate</span><span class="o">=</span><span class="n">st_coord</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


                <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">waterfill_starting_label_to_soma_border</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span>
                                                   <span class="n">border_vertices</span><span class="o">=</span><span class="n">curr_soma_border</span><span class="p">,</span>
                                                    <span class="n">label_to_expand</span><span class="o">=</span><span class="n">label_to_expand</span><span class="p">,</span>
                                                   <span class="n">total_face_labels</span><span class="o">=</span><span class="n">face_coloring_copy</span><span class="p">,</span>
                                                   <span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


        <span class="c1"># -- splitting the mesh pieces into individual pieces</span>
        <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">face_coloring_copy</span><span class="p">)</span>

        <span class="c1">#-- check that all the split mesh pieces are one component --#</span>

        <span class="c1">#save off the new data as branch mesh</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divided_submeshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="c1">#clean the limb correspondence that we do not need</span>
            <span class="k">del</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;correspondence_face_idx&quot;</span><span class="p">]</span>
<span class="c1">#             total_widths.append(limb_correspondence[limb_idx][k][&quot;width_from_skeleton&quot;])</span>
<span class="c1">#             total_branch_skeletons.append(limb_correspondence[limb_idx][k][&quot;branch_skeleton&quot;])</span>
<span class="c1">#             total_branch_meshes.append(limb_correspondence[limb_idx][k][&quot;branch_mesh&quot;])</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for limb mesh processing = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mesh_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">limb_correspondence</span></div>



<span class="c1"># ===================== For helping to split limbs at base ===================== #</span>


<div class="viewcode-block" id="check_if_branch_needs_splitting"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.check_if_branch_needs_splitting">[docs]</a><span class="k">def</span> <span class="nf">check_if_branch_needs_splitting</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">curr_soma_mesh</span><span class="p">,</span>
                                    <span class="n">significant_skeleton_threshold</span><span class="o">=</span><span class="mi">30000</span><span class="p">,</span>
                                   <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Checks to see if a certian limb needs splitting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="c1">#1) get the starting node:</span>
    <span class="n">curr_starting_branch_idx</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_starting_branch_by_soma</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)</span>
    <span class="c1">#a. Get the staring branch skeleton and find the closest skeleton point to the soma border</span>
    <span class="n">curr_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">curr_starting_branch_idx</span><span class="p">]</span>
    <span class="n">curr_branch_sk</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span>
    <span class="c1">#b. find the closest skeleton point to the soma border</span>
    <span class="n">curr_soma_border</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_concept_network_data_by_soma</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
    <span class="n">unique_skeleton_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_branch_sk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">curr_soma_border_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">curr_soma_border</span><span class="p">)</span>
    <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">curr_soma_border_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">unique_skeleton_nodes</span><span class="p">)</span>
    <span class="n">cut_coordinate</span> <span class="o">=</span> <span class="n">unique_skeleton_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">),:]</span>
    
    <span class="c1">#c. cut the limb skeleton at that point</span>
    <span class="n">curr_limb_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>

    <span class="n">node_to_cut</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">curr_limb_sk_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">cut_coordinate</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_to_cut</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Node to cut was not of length 1&quot;</span><span class="p">)</span>

    <span class="n">node_to_cut</span> <span class="o">=</span> <span class="n">node_to_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1">#c. Seperate the graph into 2 components, If there are 2 connected components after cut, are the connected components both significant</span>
    <span class="n">curr_limb_sk_graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node_to_cut</span><span class="p">)</span>

    <span class="n">seperated_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_limb_sk_graph</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seperated_components</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
        <span class="c1">#raise Exception(f&quot;Continue to next limb because number of seperated_components = {len(seperated_components)}&quot;)</span>

    <span class="c1">#c1. Seperate the graph into subgraph based on components and output the skeletons from each</span>
    <span class="n">seperated_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">curr_limb_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">seperated_components</span><span class="p">]</span>
    <span class="n">skeleton_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">seperated_skeletons</span><span class="p">])</span>


    <span class="n">n_significant_skeletons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skeleton_lengths</span><span class="o">&gt;</span><span class="n">significant_skeleton_threshold</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_significant_skeletons=</span><span class="si">{</span><span class="n">n_significant_skeletons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_lengths = </span><span class="si">{</span><span class="n">skeleton_lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_significant_skeletons</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cut_coordinate</span></div>
        <span class="c1">#raise Exception(f&quot;Continue to next limb because n_significant_skeletons = {n_significant_skeletons} with lengths {skeleton_lengths}&quot;)</span>

        
<div class="viewcode-block" id="split_limb_on_soma"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.split_limb_on_soma">[docs]</a><span class="k">def</span> <span class="nf">split_limb_on_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">curr_soma_mesh</span><span class="p">,</span>
                       <span class="n">current_neuron_mesh</span><span class="p">,</span>
                       <span class="n">soma_meshes</span><span class="p">,</span>
                       <span class="n">cut_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will actually do the limb splitting</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) get the starting node:</span>
    <span class="n">curr_starting_branch_idx</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_starting_branch_by_soma</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)</span>
    <span class="c1">#a. Get the staring branch skeleton and find the closest skeleton point to the soma border</span>
    <span class="n">curr_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">curr_starting_branch_idx</span><span class="p">]</span>
    <span class="n">curr_branch_sk</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span>
    
    <span class="k">if</span> <span class="n">cut_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Having to recalculate the cut coordinate&quot;</span><span class="p">)</span>
        
        <span class="c1">#b. find the closest skeleton point to the soma border</span>
        <span class="n">curr_soma_border</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_concept_network_data_by_soma</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
        <span class="n">unique_skeleton_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_branch_sk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">curr_soma_border_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">curr_soma_border</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">curr_soma_border_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">unique_skeleton_nodes</span><span class="p">)</span>
        <span class="n">cut_coordinate</span> <span class="o">=</span> <span class="n">unique_skeleton_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">),:]</span>
    
    
    
    <span class="c1"># --------------- Part A: Finding the new split skeletons ------------------------- #</span>
    <span class="c1"># Finding the node to cut on the BRANCH skeleton</span>
    <span class="n">curr_branch_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_branch_sk</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cut_coordinate=</span><span class="si">{</span><span class="n">cut_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">node_to_cut</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">curr_branch_sk_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">cut_coordinate</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_to_cut</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Node to cut was not of length 1&quot;</span><span class="p">)</span>

    <span class="n">node_to_cut</span> <span class="o">=</span> <span class="n">node_to_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">curr_branch_sk_graph</span>
    <span class="n">endpoint_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">endpoint_nodes_coord</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_branch_sk_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">endpoint_nodes</span><span class="p">)</span>
    <span class="n">paths_to_endpt</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_to_cut</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">endpoint_nodes</span><span class="p">]</span>
    <span class="n">path_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">paths_to_endpt</span><span class="p">])</span>
    <span class="n">closest_endpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span>
    <span class="n">farthest_endpoint</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">closest_endpoint</span>
    <span class="n">closest_endpoint_len</span> <span class="o">=</span> <span class="n">path_lengths</span><span class="p">[</span><span class="n">closest_endpoint</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">closest_endpoint_len</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#need to readjust the node_to_cut and paths</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Having to readjust endpoint&quot;</span><span class="p">)</span>
        <span class="n">node_to_cut</span> <span class="o">=</span> <span class="n">paths_to_endpt</span><span class="p">[</span><span class="n">farthest_endpoint</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">paths_to_endpt</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_to_cut</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">endpoint_nodes</span><span class="p">]</span>

    <span class="c1">#generate the subnode in each graph</span>
    <span class="n">paths_to_endpt</span><span class="p">[</span><span class="n">farthest_endpoint</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node_to_cut</span><span class="p">)</span>

    <span class="n">subgraph_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">paths_to_endpt</span><span class="p">]</span>

    <span class="n">starting_endpoints</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_branch_sk_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">paths_to_endpt</span><span class="p">])</span>


    <span class="c1">#export the skeletons of the subgraphs</span>
    <span class="n">exported_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subgraph_list</span><span class="p">]</span>
    <span class="n">endpoint_nodes_coord</span> <span class="c1">#will have the endpoints belonging to each split</span>
    
    
    <span class="c1"># --------------- Part B: Getting Initial Mesh Correspondence ------------------------- #</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3) Do Mesh correspondnece to get new branch meshes for the split skeleton</span>
<span class="sd">    - where have to do face resolving as well</span>
<span class="sd">    4) Check that both of the meshes are touching the soma</span>
<span class="sd">    5) If one of them is not touching the soma</span>
<span class="sd">    --&gt; do water growing algorithm until it is</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">div_st_branch_face_corr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">div_st_branch_width</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sub_sk</span> <span class="ow">in</span> <span class="n">exported_skeletons</span><span class="p">:</span>
        <span class="n">curr_branch_face_correspondence</span><span class="p">,</span> <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">mesh_correspondence_adaptive_distance</span><span class="p">(</span><span class="n">sub_sk</span><span class="p">,</span>
                                                  <span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                 <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                                                 <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">div_st_branch_face_corr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_branch_face_correspondence</span><span class="p">)</span>
        <span class="n">div_st_branch_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">width_from_skeleton</span><span class="p">)</span>
    
    
    <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">groups_of_labels_to_resolved_labels</span><span class="p">(</span><span class="n">current_mesh</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                          <span class="n">face_correspondence_lists</span><span class="o">=</span><span class="n">div_st_branch_face_corr</span><span class="p">)</span>
    
    
<span class="c1">#     # ------------ Intermediate part where intentionally messing up --------------- #    </span>
<span class="c1">#     label_to_expand = 1</span>

<span class="c1">#     #0) Turn the mesh into a graph</span>
<span class="c1">#     total_mesh_graph = nx.from_edgelist(curr_branch.mesh.face_adjacency)</span>

<span class="c1">#     #1) Get the nodes that represent the border</span>
<span class="c1">#     border_vertices =  curr_limb.get_concept_network_data_by_soma(soma_idx)[&quot;touching_soma_vertices&quot;]</span>
<span class="c1">#     border_faces = tu.vertices_coordinates_to_faces(curr_branch.mesh,border_vertices)</span>

<span class="c1">#     label_face_idx = divided_submeshes_idx[label_to_expand]</span>

<span class="c1">#     final_faces = label_face_idx.copy()</span>

<span class="c1">#     for i in range(0,40):</span>
<span class="c1">#         final_faces = np.unique(np.concatenate([xu.get_neighbors(total_mesh_graph,k) for k in final_faces]))</span>

<span class="c1">#     other_mesh_faces = np.delete(np.arange(0,len(curr_branch.mesh.faces)),final_faces)</span>
    
<span class="c1">#     divided_submeshes_idx = [other_mesh_faces,final_faces]</span>
<span class="c1">#     divided_submeshes = [curr_branch.mesh.submesh([k],append=True) for k in divided_submeshes_idx]</span>
    
<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes=list(divided_submeshes),</span>
<span class="c1">#                            other_meshes_colors=[&quot;black&quot;,&quot;red&quot;],</span>
<span class="c1">#                           other_skeletons=exported_skeletons,</span>
<span class="c1">#                           other_skeletons_colors=[&quot;black&quot;,&quot;red&quot;],)</span>
    
    
    
    <span class="c1"># ---------------- Part C: Checking that both pieces are touching the soma ------------- #</span>
    <span class="n">touching_pieces</span><span class="p">,</span><span class="n">touching_pieces_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">curr_soma_mesh</span><span class="p">]),</span>
                           <span class="n">central_piece</span><span class="o">=</span><span class="n">curr_soma_mesh</span><span class="p">,</span>
                           <span class="n">periphery_pieces</span><span class="o">=</span><span class="n">divided_submeshes</span><span class="p">,</span>
                           <span class="n">merge_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">return_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;touching_pieces = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
    <span class="c1"># --------------- Part D: Doing Waterfilling Unitl Both Pieces are Touching Soma ------------- #</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There were none of the new meshes that were touching the soma&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1">#find which piece was not touching</span>
        <span class="n">label_to_expand</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_mesh </span><span class="si">{</span><span class="n">label_to_expand</span><span class="si">}</span><span class="s2"> was not touching the mesh so need to expand until touches soma&quot;</span><span class="p">)</span>

        <span class="c1">#0) Turn the mesh into a graph</span>
        <span class="n">total_mesh_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">face_adjacency</span><span class="p">)</span>

        <span class="c1">#1) Get the nodes that represent the border</span>
        <span class="n">border_vertices</span> <span class="o">=</span>  <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_concept_network_data_by_soma</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
        <span class="n">border_faces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">vertices_coordinates_to_faces</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">border_vertices</span><span class="p">))</span>

        <span class="n">label_face_idx</span> <span class="o">=</span> <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">label_to_expand</span><span class="p">]</span>

        <span class="n">final_faces</span> <span class="o">=</span> <span class="n">label_face_idx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">n_touching_soma</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">n_touching_soma</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">final_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">total_mesh_graph</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">final_faces</span><span class="p">]))</span>
            <span class="n">n_touching_soma</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_faces</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">final_faces</span><span class="p">)))</span>
            <span class="n">counter</span><span class="o">+=</span> <span class="mi">1</span>


        <span class="n">other_mesh_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">final_faces</span><span class="p">)</span>

        


        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2"> iterations to expand the label back&quot;</span><span class="p">)</span>

        <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">label_to_expand</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_faces</span>
        <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">other_mesh_faces</span>

        <span class="c1">#Need to fix the labels one more time to make sure the expansion did not cut off one of the labels</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;divided_submeshes_idx = </span><span class="si">{</span><span class="n">divided_submeshes_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">groups_of_labels_to_resolved_labels</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">divided_submeshes_idx</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;divided_submeshes_idx = </span><span class="si">{</span><span class="n">divided_submeshes_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">divided_submeshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">divided_submeshes_idx</span><span class="p">]</span>

        <span class="c1">#recalculate the border vertices and the list should be 2</span>
        <span class="n">touching_pieces</span><span class="p">,</span><span class="n">touching_pieces_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">curr_soma_mesh</span><span class="p">]),</span>
                               <span class="n">central_piece</span><span class="o">=</span><span class="n">curr_soma_mesh</span><span class="p">,</span>
                               <span class="n">periphery_pieces</span><span class="o">=</span><span class="n">divided_submeshes</span><span class="p">,</span>
                               <span class="n">merge_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">return_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of touching pieces not equal to 2 even after correction: </span><span class="si">{</span><span class="n">touching_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">soma_border_verts</span> <span class="o">=</span> <span class="n">touching_pieces_verts</span>

<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes=list(divided_submeshes),</span>
<span class="c1">#                                other_meshes_colors=[&quot;black&quot;,&quot;red&quot;],</span>
<span class="c1">#                               other_skeletons=exported_skeletons,</span>
<span class="c1">#                               other_skeletons_colors=[&quot;black&quot;,&quot;red&quot;],</span>
<span class="c1">#                               other_scatter=[endpoint_nodes_coord[0].reshape(-1,3),endpoint_nodes_coord[1].reshape(-1,3)],</span>
<span class="c1">#                                other_scatter_colors=[&quot;black&quot;,&quot;red&quot;],</span>
<span class="c1">#                               scatter_size=1)</span>


    
    <span class="c1"># ----------------- Part E: Check that the mesh can&#39;t be split ----------------- #</span>
    
    <span class="c1"># check that the mesh can&#39;t be split</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">sub</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">divided_submeshes</span><span class="p">):</span>
        <span class="n">c_mesh</span><span class="p">,</span><span class="n">c_indic</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_mesh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> had </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">c_mesh</span><span class="p">)</span><span class="si">}</span><span class="s2"> pieces after split&quot;</span><span class="p">)</span>

            
    <span class="c1"># ----------------- Part F: Reorganize the Concept Network ----------------- #</span>
    <span class="n">neighbors_to_starting_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">curr_starting_branch_idx</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_meshes=[curr_limb[k].mesh for k in neighbors_to_starting_node + [curr_starting_branch_idx]],</span>
<span class="sd">                              other_meshes_colors=&quot;random&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">match</span><span class="o">=</span><span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighbors_to_starting_node</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">ex_neighbor</span> <span class="ow">in</span> <span class="n">neighbors_to_starting_node</span><span class="p">:</span>
        <span class="n">ex_neighbor_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">ex_neighbor</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">endpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endpoint_nodes_coord</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">ex_neighbor_branch</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span><span class="n">endpt</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">match</span><span class="p">[</span><span class="n">ex_neighbor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="c1">#make sure that there was only one match</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Neighbor </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> did not have one matching but instead had </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
   
    <span class="n">concept_network_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
    <span class="n">concept_network_copy</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">curr_starting_branch_idx</span><span class="p">)</span>
    <span class="n">concept_conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">concept_network_copy</span><span class="p">))</span>

    <span class="c1">#divide up the connected components into the groups they belong to</span>
    <span class="n">new_branch_groups</span> <span class="o">=</span> <span class="p">[[],[]]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">concept_conn_comp</span><span class="p">:</span>
        <span class="c1">#find the matching neighbor in that</span>
        <span class="n">matching_neighbor</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">neighbors_to_starting_node</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_neighbor</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matching_neighbor was not size 1 : </span><span class="si">{</span><span class="n">matching_neighbor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">matching_neighbor</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">matching_neighbor</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_branch_groups</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="n">matching_neighbor</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

<span class="c1">#     #check that the lists are not empty (DON&#39;T ACTUALLY NEED THIS CHECK)</span>
<span class="c1">#     for i,g in enumerate(new_branch_groups):</span>
<span class="c1">#         if len(g) == 0:</span>
<span class="c1">#             raise Exception(f&quot;New branch group {i} was empty after dividing the rest of the nodes&quot;)</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_branch_groups = </span><span class="si">{</span><span class="n">new_branch_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    
    <span class="c1"># Visualize that correctly split</span>
<span class="c1">#     divided_neighbor_meshes = [tu.combine_meshes([curr_limb[k].mesh for k in curr_group]) for curr_group in new_branch_groups]</span>
<span class="c1">#     divided_neighbor_meshes_with_original = [tu.combine_meshes([k,v]) for k,v in zip(divided_neighbor_meshes,divided_submeshes)]</span>
<span class="c1">#     #sk.graph_skeleton_and_mesh(other_meshes=)</span>
<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes=divided_neighbor_meshes_with_original,</span>
<span class="c1">#                               other_meshes_colors=[&quot;black&quot;,&quot;red&quot;],</span>
<span class="c1">#                               other_skeletons=exported_skeletons,</span>
<span class="c1">#                               other_skeletons_colors=[&quot;black&quot;,&quot;red&quot;],</span>
<span class="c1">#                               other_scatter=[endpoint_nodes_coord[0].reshape(-1,3),endpoint_nodes_coord[1].reshape(-1,3)],</span>
<span class="c1">#                                other_scatter_colors=[&quot;black&quot;,&quot;red&quot;],)</span>

    
    <span class="c1"># ----------------- Part G: Put Everything Back into a Limb Object ----------------- #</span>
    <span class="n">new_limbs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_new_branch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_branch_groups</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on new limb </span><span class="si">{</span><span class="n">curr_new_branch_idx</span><span class="si">}</span><span class="s2"> -------&quot;</span><span class="p">)</span>
        
        <span class="c1">#new_limb_dict[curr_new_branch_idx][&quot;soma_border_verts&quot;] = soma_border_verts[curr_new_branch_idx]</span>

        <span class="c1"># a) Creating the new concept network</span>
        <span class="n">curr_limb_divided_skeletons</span> <span class="o">=</span>  <span class="p">[</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_branch_groups</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">exported_skeletons</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">]]</span>
        <span class="n">closest_endpoint</span> <span class="o">=</span> <span class="n">starting_endpoints</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">]</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">exported_skeletons</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">])</span><span class="o">.</span><span class="n">endpoints</span>
        <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branches_to_concept_network</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">,</span><span class="n">closest_endpoint</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                                            <span class="n">touching_soma_vertices</span><span class="o">=</span> <span class="n">soma_border_verts</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">])</span>

        <span class="c1">#Run some checks on the new concept network developed</span>
        <span class="n">curr_starting_branch_idx</span><span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">check_concept_network</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">closest_endpoint</span> <span class="o">=</span> <span class="n">closest_endpoint</span><span class="p">,</span>
                                  <span class="n">curr_limb_divided_skeletons</span><span class="o">=</span><span class="n">curr_limb_divided_skeletons</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># b) Creating the new mesh</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Old way: </span>
<span class="sd">        remaining_meshes_faces_idx =  [curr_limb[k].mesh_face_idx for k in new_branch_groups[curr_new_branch_idx]]</span>
<span class="sd">        remaining_meshes_faces_idx.append(np.array(curr_branch.mesh_face_idx[divided_submeshes_idx[curr_new_branch_idx]]))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_limb_branch_face_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">remaining_meshes_face_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_face_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_branch_groups</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">]:</span>
            <span class="n">curr_face_idx</span>  <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span>
            <span class="n">remaining_meshes_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_face_idx</span><span class="p">)</span>
            <span class="n">new_limb_branch_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">total_face_count</span><span class="p">,</span><span class="n">total_face_count</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_face_idx</span><span class="p">)))</span>
            <span class="n">total_face_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_face_idx</span><span class="p">)</span>

        <span class="n">last_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">[</span><span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">]])</span>
        <span class="n">remaining_meshes_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_face_idx</span><span class="p">)</span>
        <span class="n">new_limb_branch_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">total_face_count</span><span class="p">,</span><span class="n">total_face_count</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">last_face_idx</span><span class="p">)))</span>


        <span class="n">final_remaining_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">remaining_meshes_face_idx</span><span class="p">)</span>                         
        <span class="n">curr_new_limb_mesh</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">final_remaining_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checking that it went well:</span>
<span class="sd">        reovered_mesh = curr_new_limb_mesh.submesh([new_limb_branch_face_idx[2]],append=True,repair=False)</span>
<span class="sd">        original_mesh = curr_limb[new_branch_groups[curr_new_branch_idx][2]].mesh</span>
<span class="sd">        reovered_mesh,original_mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">curr_limb_correspondence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">neighb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_branch_groups</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">]):</span>
            <span class="c1">#calculate the new mesh correspondence</span>
            <span class="n">curr_limb_correspondence</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">branch_skeleton</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">neighb</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                              <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">neighb</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                                              <span class="n">branch_mesh</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">neighb</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                              <span class="n">branch_face_idx</span><span class="o">=</span><span class="n">new_limb_branch_face_idx</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="c1">#add on the new mesh</span>
        <span class="n">curr_limb_correspondence</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">new_branch_groups</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">])]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">branch_skeleton</span> <span class="o">=</span> <span class="n">exported_skeletons</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">],</span>
                        <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">div_st_branch_width</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">],</span>
                        <span class="n">branch_mesh</span><span class="o">=</span><span class="n">divided_submeshes</span><span class="p">[</span><span class="n">curr_new_branch_idx</span><span class="p">],</span>
                        <span class="n">branch_face_idx</span><span class="o">=</span><span class="n">new_limb_branch_face_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># curr_limb_concept_network_dicts = [dict(starting_endpoints=endpoints,</span>
        <span class="c1">#                                        starting_node=curr_starting_branch_idx,</span>
        <span class="c1">#                                        starting_soma=soma_idx,</span>
        <span class="c1">#                                        starting_coordinate=closest_endpoint)]</span>
        <span class="n">curr_limb_concept_network_dicts</span> <span class="o">=</span> <span class="p">{</span><span class="n">soma_idx</span><span class="p">:</span><span class="n">curr_limb_concept_network</span><span class="p">}</span>

        <span class="n">new_limb_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">curr_new_limb_mesh</span><span class="p">,</span>
                                   <span class="n">curr_limb_correspondence</span><span class="o">=</span><span class="n">curr_limb_correspondence</span><span class="p">,</span>
                                   <span class="n">concept_network_dict</span><span class="o">=</span><span class="n">curr_limb_concept_network_dicts</span><span class="p">)</span>
        <span class="n">new_limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">compute_all_concept_network_data_from_limb</span><span class="p">(</span><span class="n">new_limb_obj</span><span class="p">,</span>
                                                                                               <span class="n">current_neuron_mesh</span><span class="o">=</span><span class="n">current_neuron_mesh</span><span class="p">,</span>
                                                                                              <span class="n">soma_meshes</span><span class="o">=</span><span class="n">soma_meshes</span><span class="p">)</span>

        <span class="n">new_limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_limb_obj</span><span class="p">)</span>
        <span class="c1">#new_limb_dict[curr_new_branch_idx][&quot;curr_starting_branch_idx&quot;] = new_limb_obj.current_starting_node</span>
        
    <span class="k">return</span> <span class="n">new_limbs</span></div>


<div class="viewcode-block" id="recursive_limb_splitting"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.recursive_limb_splitting">[docs]</a><span class="k">def</span> <span class="nf">recursive_limb_splitting</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">current_neuron_mesh</span><span class="p">,</span><span class="n">significant_skeleton_threshold</span><span class="o">=</span><span class="mi">30000</span><span class="p">,</span>
                            <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To split the a limb as many times as needed if connected at the soma</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get all the somas that the limb is attached to (from all_concept_network_data)</span>
<span class="sd">    2) For each soma it is attached to, check if it needs to be split:</span>
<span class="sd">    </span>
<span class="sd">    If yes:</span>
<span class="sd">    a. Split the limb into its parts for that soma</span>
<span class="sd">    b. Compute the all_concept_network_data for all of the split limbs</span>
<span class="sd">    c. Start loop where send all of the limb objects through function and collect results</span>
<span class="sd">    d. concatenate results and return</span>
<span class="sd">    </span>
<span class="sd">    if No: </span>
<span class="sd">    - continue to next soma</span>
<span class="sd">    </span>
<span class="sd">    if No and the last soma</span>
<span class="sd">    - return the limb object</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">    1) Limb</span>
<span class="sd">    2) Soma</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    ex_limb = current_neuron[2]</span>
<span class="sd">    split_limbs = recursive_limb_splitting(current_neuron,ex_limb)</span>

<span class="sd">    color_choices = [&quot;red&quot;,&quot;black&quot;]</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_meshes=[split_limbs[0].mesh,split_limbs[1].mesh],</span>
<span class="sd">                               other_meshes_colors=color_choices,</span>
<span class="sd">                               other_skeletons=[split_limbs[0].skeleton,split_limbs[1].skeleton],</span>
<span class="sd">                               other_skeletons_colors=color_choices)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) Get all the somas that the limb is attached to (from all_concept_network_data)</span>
    <span class="n">total_somas_idx</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()</span>
    <span class="n">total_soams_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_somas_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_somas_idx = </span><span class="si">{</span><span class="n">total_somas_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_soams_meshes = </span><span class="si">{</span><span class="n">total_soams_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#2) For each soma it is attached to, check if it needs to be split:</span>
    <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">curr_soma_mesh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">total_somas_idx</span><span class="p">,</span><span class="n">total_soams_meshes</span><span class="p">):</span>
        
        <span class="n">cut_coordinate</span> <span class="o">=</span> <span class="n">check_if_branch_needs_splitting</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">curr_soma_mesh</span><span class="p">,</span>
                                   <span class="n">significant_skeleton_threshold</span><span class="o">=</span><span class="n">significant_skeleton_threshold</span><span class="p">,</span>
                                   <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cut_coordinate = </span><span class="si">{</span><span class="n">cut_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># If No then continue to next soma</span>
        <span class="k">if</span> <span class="n">cut_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
            
        <span class="c1">#If yes:</span>
        <span class="c1">#a. Split the limb into its parts for that soma and</span>
        <span class="c1">#b. Compute the all_concept_network_data for all of the split limbs</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="n">split_limb_objs</span> <span class="o">=</span> <span class="n">split_limb_on_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">curr_soma_mesh</span><span class="p">,</span>
                                                 <span class="n">current_neuron_mesh</span> <span class="o">=</span> <span class="n">current_neuron_mesh</span><span class="p">,</span>
                                                 <span class="n">soma_meshes</span><span class="o">=</span><span class="n">soma_meshes</span><span class="p">,</span>
                                                 <span class="n">cut_coordinate</span><span class="o">=</span><span class="n">cut_coordinate</span><span class="p">,</span>
                                                <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">():</span>
                <span class="n">split_limb_objs</span> <span class="o">=</span> <span class="n">split_limb_on_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">curr_soma_mesh</span><span class="p">,</span>
                                                     <span class="n">current_neuron_mesh</span> <span class="o">=</span> <span class="n">current_neuron_mesh</span><span class="p">,</span>
                                                     <span class="n">soma_meshes</span><span class="o">=</span><span class="n">soma_meshes</span><span class="p">,</span>
                                                 <span class="n">cut_coordinate</span><span class="o">=</span><span class="n">cut_coordinate</span><span class="p">,</span>
                                                <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split_limb_objs = </span><span class="si">{</span><span class="n">split_limb_objs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">total_split_limbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">split_limb</span> <span class="ow">in</span> <span class="n">split_limb_objs</span><span class="p">:</span>
            <span class="n">curr_results</span> <span class="o">=</span> <span class="n">recursive_limb_splitting</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">=</span><span class="n">split_limb</span><span class="p">,</span>
                                                    <span class="n">soma_meshes</span><span class="o">=</span><span class="n">soma_meshes</span><span class="p">,</span>
                                                    <span class="n">current_neuron_mesh</span> <span class="o">=</span> <span class="n">current_neuron_mesh</span><span class="p">,</span>
                                     <span class="n">significant_skeleton_threshold</span><span class="o">=</span><span class="n">significant_skeleton_threshold</span><span class="p">,</span>
                                    <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">)</span>
            <span class="n">total_split_limbs</span> <span class="o">=</span> <span class="n">total_split_limbs</span> <span class="o">+</span> <span class="n">curr_results</span>
        <span class="k">return</span> <span class="n">total_split_limbs</span>
        
    <span class="c1">#If Did not need to split any of then return the current limb</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hit Recursive return point and returning limb&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">curr_limb</span><span class="p">]</span></div>


<span class="c1">#nru = reload(nru)</span>

<div class="viewcode-block" id="limb_split"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.limb_split">[docs]</a><span class="k">def</span> <span class="nf">limb_split</span><span class="p">(</span><span class="n">limbs</span><span class="p">,</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">current_neuron_mesh</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will end up giving new limb correspondence</span>
<span class="sd">    and other information that corresponds to limbs that have been split</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    current_file = &quot;/notebooks/test_neurons/meshafterparty_processed/12345_double_soma_meshafterparty&quot;</span>
<span class="sd">    neuron_obj = nru.decompress_neuron(filepath=current_file,</span>
<span class="sd">                                      original_mesh=current_file,</span>
<span class="sd">                                      minimal_output=True)</span>

<span class="sd">    </span>
<span class="sd">    limbs = [current_neuron[k] for k in current_neuron.get_limb_node_names(return_int=True)]</span>
<span class="sd">    soma_meshes = [current_neuron.concept_network.nodes[nru.soma_label(k)][&quot;data&quot;].mesh for k in [0,1]]</span>
<span class="sd">    current_neuron_mesh = current_neuron.mesh</span>

<span class="sd">    (new_limb_correspondence,</span>
<span class="sd">     new_soma_to_piece_connectivity,</span>
<span class="sd">     new_limb_meshes,</span>
<span class="sd">     new_limb_concept_networks,</span>
<span class="sd">     new_limb_labels) = limb_split(limbs,soma_meshes,current_neuron_mesh)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    will map the [limb_idx AS A NUMBER][branch_idx] to </span>
<span class="sd">    dict_keys([&#39;branch_skeleton&#39;, &#39;width_from_skeleton&#39;, &#39;branch_mesh&#39;, &#39;branch_face_idx&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_limb_correspondence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps Soma to who they are connected to</span>
<span class="sd">    Ex: {0: [0, 1, 3, 4, 5, 9], 1: [1, 2, 6, 7, 8]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_soma_to_piece_connectivity</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">)])</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Just a list that will hold all of the meshes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_limb_meshes</span> <span class="o">=</span> <span class="p">[]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a dictionary that maps the limb_idx to a dictionary mapping the soma_idx to the concept map</span>
<span class="sd">    {0:{0:Graph},</span>
<span class="sd">     1:{0:Graph,1:Graph},</span>
<span class="sd">     2:{1:Graph}....}</span>

<span class="sd">    ** can easily get this from the limb property concept_network_data_by_soma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_limb_concept_networks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Labels for the limbs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_limb_labels</span> <span class="o">=</span> <span class="p">[]</span>



<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through each split limb</span>
<span class="sd">    1) Get all of the split limbs from that one limb</span>
<span class="sd">    For each limb :</span>
<span class="sd">    -look at the current length of the new_limb_meshes to get the current index for limb</span>
<span class="sd">    a) Add a new entry in the new_limb_correspondence by iterating over the branches</span>
<span class="sd">    b) get the somas that touch the limb and add CURRENT INDEX them to the new_soma_to_piece_connectivity dictionary</span>
<span class="sd">    c) Add the limb mesh to new_limb_meshes</span>
<span class="sd">    d) Use the concept_network_data_by_soma attribute to get the concept_network dictionary and add to </span>
<span class="sd">        new_limb_concept_networks</span>
<span class="sd">    e) make new merge labels based on the number of connections in the concept_network_data</span>
<span class="sd">    &quot;&quot;&quot;</span>



    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limbs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----- Working on Limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">--------&quot;</span><span class="p">)</span>
        <span class="n">split_limbs</span> <span class="o">=</span> <span class="n">recursive_limb_splitting</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_meshes</span><span class="p">,</span>
                                              <span class="n">current_neuron_mesh</span><span class="o">=</span><span class="n">current_neuron_mesh</span><span class="p">,</span>
                                              <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">split_limbs</span><span class="p">)</span><span class="si">}</span><span class="s2"> limbs after limb split&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sp_limb</span> <span class="ow">in</span> <span class="n">split_limbs</span><span class="p">:</span>
            <span class="c1">#-look at the current length of the new_limb_meshes to get the current index for limb</span>
            <span class="n">new_limb_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_limb_meshes</span><span class="p">)</span>
            <span class="c1">#a) Add a new entry in the new_limb_correspondence by iterating over the branches</span>
            <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">new_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">curr_branch_idx</span> <span class="ow">in</span> <span class="n">sp_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
                <span class="n">curr_branch</span> <span class="o">=</span> <span class="n">sp_limb</span><span class="p">[</span><span class="n">curr_branch_idx</span><span class="p">]</span>
                <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">new_limb_idx</span><span class="p">][</span><span class="n">curr_branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                                                        <span class="n">branch_skeleton</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                        <span class="n">width_from_skeleton</span><span class="o">=</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                                                        <span class="n">branch_mesh</span><span class="o">=</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                        <span class="n">branch_face_idx</span><span class="o">=</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)</span>
            <span class="c1">#b) get the somas that touch the limb and add CURRENT INDEX them to the new_soma_to_piece_connectivity dictionary</span>
            <span class="n">touching_somas</span> <span class="o">=</span> <span class="n">sp_limb</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">touching_somas</span><span class="p">:</span>
                <span class="n">new_soma_to_piece_connectivity</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_limb_idx</span><span class="p">)</span>

            <span class="c1">#c) Add the limb mesh to new_limb_meshes</span>
            <span class="n">new_limb_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

            <span class="c1">#d) Use the concept_network_data_by_soma attribute to get the concept_network dictionary and add to </span>
            <span class="c1">#new_limb_concept_networks</span>
            <span class="n">concept_network_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sp_limb</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">():</span>
                <span class="n">sp_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
                <span class="n">concept_network_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">sp_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
            
            
            <span class="n">new_limb_concept_networks</span><span class="p">[</span><span class="n">new_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">concept_network_dict</span>

            <span class="c1">#e) make new merge labels based on the number of connections in the concept_network_data</span>
            <span class="c1"># OPtions: ([&#39;Normal&#39;], [&#39;MergeError&#39;])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp_limb</span><span class="o">.</span><span class="n">concept_network_data_by_soma</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_limb_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;MergeError&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_limb_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Normal&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">new_limb_correspondence</span><span class="p">,</span><span class="n">new_soma_to_piece_connectivity</span><span class="p">,</span><span class="n">new_limb_meshes</span><span class="p">,</span><span class="n">new_limb_concept_networks</span><span class="p">,</span><span class="n">new_limb_labels</span></div>
            
            



<span class="c1"># ------------------------ For the preprocessing ----------------------- #</span>

<div class="viewcode-block" id="preprocess_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.preprocess_neuron">[docs]</a><span class="k">def</span> <span class="nf">preprocess_neuron</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">mesh_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">segment_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">sig_th_initial_split</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="c1">#for significant splitting meshes in the intial mesh split</span>
                     <span class="n">limb_threshold</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="c1">#the mesh faces threshold for a mesh to be qualified as a limb (otherwise too small)</span>
                      <span class="n">filter_end_node_length</span><span class="o">=</span><span class="mi">4001</span><span class="p">,</span> <span class="c1">#used in cleaning the skeleton during skeletonizations</span>
                      <span class="n">return_no_somas</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">decomposition_type</span><span class="o">=</span><span class="s2">&quot;meshafterparty&quot;</span><span class="p">,</span>
                      <span class="n">mesh_correspondence</span> <span class="o">=</span> <span class="s2">&quot;meshparty&quot;</span><span class="p">,</span> <span class="c1"># USE &quot;meshafterparty_adaptive&quot; for the adaptive manner</span>
                      <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">meshparty_segment_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="n">meshparty_n_surface_downsampling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="n">somas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">branch_skeleton_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">combine_close_skeleton_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span>
                     <span class="p">):</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inside preproces neuron&quot;</span><span class="p">)</span>
    <span class="n">whole_processing_tiempo</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To process the mesh into a format that can be loaded into the neuron class</span>
<span class="sd">    and used for higher order processing (how to visualize is included)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;no_description&quot;</span>
    <span class="k">if</span> <span class="n">segment_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#pick a random segment id</span>
        <span class="n">segment_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;picking a random 7 digit segment id: </span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">description</span> <span class="o">+=</span> <span class="s2">&quot;_random_id&quot;</span>

    
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">current_mesh_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No mesh or mesh_file file were given&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">current_mesh_file</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">mesh</span>
        
    <span class="c1"># ************************ Phase A ********************************</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\n\n\n</span><span class="s2">****** Phase A ***************</span><span class="se">\n\n\n\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    
    
    
    <span class="c1"># --- 1) Doing the soma detection</span>
    <span class="k">if</span> <span class="n">somas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Using the glia soma extract!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span> 
         <span class="n">run_time</span><span class="p">,</span> 
         <span class="n">total_soma_list_sdf</span><span class="p">,</span>
         <span class="n">glia_pieces</span><span class="p">,</span>
         <span class="n">nuclei_pieces</span><span class="p">)</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">extract_soma_center</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span>
                                                 <span class="n">current_neuron</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                                 <span class="n">current_neuron</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">glia_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">))</span>
            <span class="n">n_glia_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_faces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glia_faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_glia_faces</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_pieces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">nuclei_pieces</span><span class="p">))</span>
            <span class="n">n_nuclei_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_faces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_nuclei_faces</span> <span class="o">=</span> <span class="mi">0</span>
        
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">soma_mesh_list</span><span class="p">,</span><span class="n">run_time</span><span class="p">,</span><span class="n">total_soma_list_sdf</span> <span class="o">=</span> <span class="n">somas</span>
    
    <span class="c1"># geting the soma centers</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;**** No Somas Found for Mesh </span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2"> so just one mesh&quot;</span><span class="p">)</span>
        <span class="n">soma_mesh_list_centers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">return_no_somas</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">soma_mesh_list_centers</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Processing of No Somas is not yet implemented yet&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#compute the soma centers</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma List = </span><span class="si">{</span><span class="n">soma_mesh_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">soma_mesh_list_centers</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">find_soma_centroids</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_mesh_list_centers = </span><span class="si">{</span><span class="n">soma_mesh_list_centers</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
<span class="c1">#     sk.graph_skeleton_and_mesh(main_mesh_verts=current_neuron.vertices,</span>
<span class="c1">#                           main_mesh_faces=current_neuron.faces,</span>
<span class="c1">#                            main_mesh_color = [0.,1.,0.,0.8]</span>
<span class="c1">#                           )</span>

    <span class="c1"># ********At this point assume that there are somas (if not would just skip to the limb skeleton stuff) *******</span>
    
    
    
    
    
    
    
    
    <span class="c1">#--- 2) getting the soma submeshes that are connected to each soma and identifiying those that aren&#39;t (and eliminating any mesh pieces inside the soma)</span>
    
    <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">current_neuron</span>
    

    <span class="c1">#finding the mesh pieces that contain the soma</span>
    <span class="c1">#splitting the current neuron into distinct pieces</span>
    <span class="n">split_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span>
                                <span class="n">main_mesh_total</span><span class="p">,</span>
                                <span class="n">significance_threshold</span><span class="o">=</span><span class="n">sig_th_initial_split</span><span class="p">,</span>
                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# total split meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#returns the index of the split_meshes index that contains each soma    </span>
    <span class="n">containing_mesh_indices</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">find_soma_centroid_containing_meshes</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span>
                                            <span class="n">split_meshes</span><span class="p">)</span>
    
    <span class="c1"># filtering away any of the inside floating pieces: </span>
    <span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>


    <span class="c1">#Adding the step that will filter away any pieces that are inside the soma</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *** want to save these pieces that are inside of the soma***</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">non_soma_touching_meshes</span><span class="p">,</span><span class="n">inside_pieces</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">filter_away_inside_soma_pieces</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                        <span class="n">significance_threshold</span><span class="o">=</span><span class="n">sig_th_initial_split</span><span class="p">,</span>
                                        <span class="n">return_inside_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>                                                      


    <span class="n">split_meshes</span> <span class="c1"># the meshes of the original mesh</span>
    <span class="n">containing_mesh_indices</span> <span class="c1">#the mapping of each soma centroid to the correct split mesh</span>
    <span class="n">soma_containing_meshes</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">grouping_containing_mesh_indices</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="p">)</span>

    <span class="n">soma_touching_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_containing_meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>


<span class="c1">#     print(f&quot;# of non soma touching seperate meshes = {len(non_soma_touching_meshes)}&quot;)</span>
<span class="c1">#     print(f&quot;# of inside pieces = {len(inside_pieces)}&quot;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of soma containing seperate meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_touching_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;meshes with somas = </span><span class="si">{</span><span class="n">soma_containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

   
    

    
    
    
    <span class="c1">#--- 3)  Soma Extraction was great (but it wasn&#39;t the original soma faces), so now need to get the original soma faces and the original non-soma faces of original pieces</span>
    
<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes=[soma_meshes])</span>

<span class="w">    </span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for each soma touching mesh get the following:</span>
<span class="sd">    1) original soma meshes</span>
<span class="sd">    2) significant mesh pieces touching these somas</span>
<span class="sd">    3) The soma connectivity to each of the significant mesh pieces</span>
<span class="sd">    -- later will just translate the </span>


<span class="sd">    Process: </span>

<span class="sd">    1) Final all soma faces (through soma extraction and then soma original faces function)</span>
<span class="sd">    2) Subtact all soma faces from original mesh</span>
<span class="sd">    3) Find all significant mesh pieces</span>
<span class="sd">    4) Backtrack significant mesh pieces to orignal mesh and find connectivity of each to all</span>
<span class="sd">       the available somas</span>
<span class="sd">    Conclusion: Will have connectivity map</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">soma_touching_mesh_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">z</span><span class="p">,(</span><span class="n">mesh_idx</span><span class="p">,</span> <span class="n">soma_idxes</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_containing_meshes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">----Working on soma-containing mesh piece </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">----&quot;</span><span class="p">)</span>

        <span class="c1">#1) Final all soma faces (through soma extraction and then soma original faces function)</span>
        <span class="n">current_mesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="n">mesh_idx</span><span class="p">]</span>

        <span class="n">current_soma_mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_mesh_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_idxes</span><span class="p">]</span>

        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">mesh_pieces_without_soma</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">subtract_soma</span><span class="p">(</span><span class="n">current_soma_mesh_list</span><span class="p">,</span><span class="n">current_mesh</span><span class="p">,</span>
                                                    <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Subtract Soam = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">mesh_pieces_without_soma_stacked</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">mesh_pieces_without_soma</span><span class="p">)</span>

        <span class="c1"># find the original soma faces of mesh</span>
        <span class="n">soma_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">mesh_pieces_without_soma_stacked</span><span class="p">,</span><span class="n">matching</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Original_mesh_faces_map for mesh_pieces without soma= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">soma_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># finding the non-soma original faces</span>
        <span class="n">non_soma_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">matching</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">non_soma_stacked_mesh</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">non_soma_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Original_mesh_faces_map for somas= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># 3) Find all significant mesh pieces</span>
        <span class="n">sig_non_soma_pieces</span><span class="p">,</span><span class="n">insignificant_limbs</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">non_soma_stacked_mesh</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="n">limb_threshold</span><span class="p">,</span>
                                                         <span class="n">return_insignificant_pieces</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for sig_non_soma_pieces= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_non_soma_pieces</span>

        <span class="c1">#4) Backtrack significant mesh pieces to orignal mesh and find connectivity of each to all the available somas</span>
        <span class="c1"># get all the seperate mesh faces</span>

        <span class="c1">#How to seperate the mesh faces</span>
        <span class="n">seperate_soma_meshes</span><span class="p">,</span><span class="n">soma_face_components</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1">#take the top largest ones depending how many were originally in the soma list</span>
        <span class="n">seperate_soma_meshes</span> <span class="o">=</span> <span class="n">seperate_soma_meshes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)]</span>
        <span class="n">soma_face_components</span> <span class="o">=</span> <span class="n">soma_face_components</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)]</span>

        <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seperate_soma_meshes</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for split= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>



        <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">limb_root_nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">curr_soma</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seperate_soma_meshes</span><span class="p">):</span>
            <span class="n">connected_mesh_pieces</span><span class="p">,</span><span class="n">connected_mesh_pieces_vertices</span>  <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span>
                            <span class="n">main_mesh</span><span class="o">=</span><span class="n">current_mesh</span><span class="p">,</span>
                            <span class="n">central_piece</span><span class="o">=</span><span class="n">curr_soma</span><span class="p">,</span>
                            <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">sig_non_soma_pieces</span><span class="p">,</span>
                            <span class="n">return_vertices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="c1">#print(f&quot;soma {i}: connected_mesh_pieces = {connected_mesh_pieces}&quot;)</span>
            <span class="n">soma_to_piece_connectivity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">connected_mesh_pieces</span>
            
            <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">piece_index</span><span class="p">,</span><span class="n">piece_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connected_mesh_pieces</span><span class="p">):</span>
                <span class="n">limb_root_nodes</span><span class="p">[</span><span class="n">piece_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">connected_mesh_pieces_vertices</span><span class="p">[</span><span class="n">piece_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">piece_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">connected_mesh_pieces_vertices</span><span class="p">[</span><span class="n">piece_index</span><span class="p">]</span>
        
<span class="c1">#         border_debug = False</span>
<span class="c1">#         if border_debug:</span>
<span class="c1">#             print(f&quot;soma_to_piece_connectivity = {soma_to_piece_connectivity}&quot;)</span>
<span class="c1">#             print(f&quot;soma_to_piece_touching_vertices = {soma_to_piece_touching_vertices}&quot;)</span>
            
       
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh_pieces_connectivity= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_to_piece_connectivity</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of insignificant_limbs = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">insignificant_limbs</span><span class="p">)</span><span class="si">}</span><span class="s2"> with trimesh : </span><span class="si">{</span><span class="n">insignificant_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    
    <span class="c1"># Lets have an alert if there was more than one soma disconnected meshes</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_touching_mesh_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;More than 1 disconnected meshes that contain somas&quot;</span><span class="p">)</span>
        
    <span class="n">current_mesh_data</span> <span class="o">=</span> <span class="n">soma_touching_mesh_data</span>
    <span class="n">soma_containing_idx</span> <span class="o">=</span> <span class="mi">0</span>
    
    
    <span class="c1"># ****Soma Touching mesh Data has the branches and the connectivity (So this is where you end up skipping if you don&#39;t have somas)***</span>
    
    
    
    
    
    
    
    
    
<span class="c1"># --------------------------------------------------- 8/28 starting with MESHAFTERPARY (for skeletonization and mesh correspondence---------------------</span>
    
    <span class="k">if</span> <span class="n">decomposition_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;meshafterparty&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using DECOMPOSITION TYPE: meshAfterParty&quot;</span><span class="p">)</span>
        <span class="c1"># ---5) Working on the Actual skeleton of all of the branches</span>


        <span class="n">global_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        

        <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">branch_skeleton_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">soma_containing_mesh_idx</span><span class="p">,</span><span class="n">mesh_data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_touching_mesh_data</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                
<span class="c1">#                 sk_debug = True</span>
<span class="c1">#                 if sk_debug:</span>
<span class="c1">#                     from python_tools import system_utils as su</span>
<span class="c1">#                     su.compressed_pickle(mesh_data[&quot;branch_meshes&quot;],</span>
<span class="c1">#                                         &quot;ordered_branch_meshes&quot;)</span>
<span class="c1">#                 raise Exception(&quot;Done exporting branches&quot;)</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-- Working on Soma Continaing Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">--&quot;</span><span class="p">)</span>
                <span class="n">current_branches</span> <span class="o">=</span> <span class="n">mesh_data</span><span class="p">[</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]</span>

                <span class="c1">#skeletonize each of the branches</span>
                <span class="n">total_skeletons</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">z</span><span class="p">,</span><span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_branches</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    -- Working on branch </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">--&quot;</span><span class="p">)</span>
<span class="c1">#                     if z != 2:</span>
<span class="c1">#                         continue</span>
                    <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="n">current_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize_connected_branch</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
                    

<span class="c1">#                     sk_debug = True</span>
<span class="c1">#                     if sk_debug:</span>
<span class="c1">#                         from python_tools import system_utils as su</span>
<span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
<span class="c1">#                         su.compressed_pickle(branch,</span>
<span class="c1">#                                             &quot;curr_branch_saved&quot;)</span>
<span class="c1">#                     if sk_debug:</span>
<span class="c1">#                         from python_tools import system_utils as su</span>
<span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
<span class="c1">#                         su.compressed_pickle(current_skeleton,</span>
<span class="c1">#                                             &quot;current_skeleton&quot;)</span>
                    
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Total time for skeletonizing branch </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clean_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;  --------- 9/17 Addition: Will make sure all branches have endpoint extending towards soma -------- &quot;&quot;&quot;</span>
                    <span class="c1">#build the soma to piece touching vertices dictionary for this neuorn</span>
                    <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">s_index</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">soma_to_piece_touching_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">z</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">curr_soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">s_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">s_index</span><span class="p">][</span><span class="n">z</span><span class="p">]</span>
                    
                    <span class="n">current_skeleton</span><span class="p">,</span> <span class="n">curr_limb_endpoints_must_keep</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">create_soma_extending_branches</span><span class="p">(</span>
                                    <span class="n">current_skeleton</span><span class="o">=</span><span class="n">current_skeleton</span><span class="p">,</span> <span class="c1">#current skeleton that was created</span>
                                    <span class="n">skeleton_mesh</span><span class="o">=</span><span class="n">branch</span><span class="p">,</span> <span class="c1">#mesh that was skeletonized</span>
                                    <span class="n">soma_to_piece_touching_vertices</span><span class="o">=</span><span class="n">curr_soma_to_piece_touching_vertices</span><span class="p">,</span><span class="c1">#dictionary mapping a soma it is touching to the border vertices,</span>
                                    <span class="n">return_endpoints_must_keep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                    <span class="p">)</span>
                    
                    <span class="n">endpoints_must_keep</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_limb_endpoints_must_keep</span>
                            
                    

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Total time for Fixing Skeleton Soma Endpoint Extension </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clean_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;  --------- END OF 9/17 Addition:  -------- &quot;&quot;&quot;</span>

                    <span class="c1">#                     sk_debug = True</span>
                    <span class="c1">#                     if sk_debug:</span>
                    <span class="c1">#                         from python_tools import system_utils as su</span>
                    <span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
                    <span class="c1">#                         su.compressed_pickle(current_skeleton,</span>
                    <span class="c1">#                                             &quot;current_skeleton_after_addition&quot;)</span>
                    
                    
                    
                        <span class="c1"># --------  Doing the cleaning ------- #</span>
                    <span class="n">clean_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_end_node_length = </span><span class="si">{</span><span class="n">filter_end_node_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">                    </span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot; 9/16 Edit: Now send the border vertices and don&#39;t want to clean anyy end nodes that are within certain distance of border&quot;&quot;&quot;</span>
                    
                    <span class="n">total_border_vertices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_to_piece_touching_vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">total_border_vertices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">z</span><span class="p">]</span>
                            
                    <span class="c1">#soma_border_vertices = total_border_vertices,</span>
                    <span class="c1">#skeleton_mesh=branch,</span>
                    <span class="n">new_cleaned_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">clean_skeleton</span><span class="p">(</span><span class="n">current_skeleton</span><span class="p">,</span>
                                            <span class="n">distance_func</span><span class="o">=</span><span class="n">sk</span><span class="o">.</span><span class="n">skeletal_distance</span><span class="p">,</span>
                                      <span class="n">min_distance_to_junction</span><span class="o">=</span><span class="n">filter_end_node_length</span><span class="p">,</span> <span class="c1">#this used to be a tuple i think when moved the parameter up to function defintion</span>
                                      <span class="n">return_skeleton</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">soma_border_vertices</span> <span class="o">=</span> <span class="n">total_border_vertices</span><span class="p">,</span>
                                        <span class="n">skeleton_mesh</span><span class="o">=</span><span class="n">branch</span><span class="p">,</span>
                                        <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="n">curr_limb_endpoints_must_keep</span><span class="p">,</span>
                                      <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    
<span class="c1">#                     sk_debug = True</span>
<span class="c1">#                     if sk_debug:</span>
<span class="c1">#                         from python_tools import system_utils as su</span>
<span class="c1">#                         print(&quot;**Saving the skeletons**&quot;)</span>
<span class="c1">#                         su.compressed_pickle(new_cleaned_skeleton,</span>
<span class="c1">#                                             &quot;new_cleaned_skeleton&quot;)</span>
                    
                    
                    
                    
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Total time for cleaning of branch </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">clean_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_cleaned_skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found a zero length skeleton for limb </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2"> of trmesh </span><span class="si">{</span><span class="n">branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">total_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cleaned_skeleton</span><span class="p">)</span>
                    

                <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_skeletons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_skeletons</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for skeletonization = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;***** Skipping INITIAL skeletonization because recieved pre-computed skeleton *****&quot;</span><span class="p">)</span>
            <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_skeleton_data</span>
            
            
<span class="c1">#         sk_debug = True</span>
<span class="c1">#         if sk_debug:</span>
<span class="c1">#             from python_tools import system_utils as su</span>
<span class="c1">#             from copy import deepcopy</span>
<span class="c1">#             print(&quot;**Saving the skeletons**&quot;)</span>
<span class="c1">#             su.compressed_pickle(deepcopy(soma_touching_mesh_data[j][&quot;branch_skeletons&quot;]),</span>
<span class="c1">#                                 &quot;initial_cleaned_skeletons&quot;)</span>
        
        
        <span class="n">limb_correspondence</span> <span class="o">=</span> <span class="n">further_mesh_correspondence_processing_from_skeleton</span><span class="p">(</span><span class="n">soma_touching_mesh_data</span><span class="p">,</span>
                                                                                  <span class="n">branch_skeleton_data</span><span class="o">=</span><span class="n">branch_skeleton_data</span><span class="p">,</span>
                                                                                  <span class="n">combine_close_skeleton_nodes</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes</span><span class="p">,</span>
                                                                                   <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                                                                                <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="n">combine_close_skeleton_nodes_threshold</span><span class="p">,</span>
                                                                                  <span class="n">soma_to_piece_touching_vertices</span><span class="o">=</span><span class="n">soma_to_piece_touching_vertices</span><span class="p">,</span>
                                                                                  <span class="n">endpoints_must_keep</span><span class="o">=</span><span class="n">endpoints_must_keep</span><span class="p">)</span>
        
        

    
<span class="c1"># --------------------------------- WHERE FINISH WITH meshAFTERpary option -------------------------------------------- #</span>

<span class="c1"># --------------------------------- where START with meshparty option ------------------------------------------------ #</span>
    <span class="k">elif</span> <span class="n">decomposition_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;meshparty&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using DECOMPOSITION TYPE: meshparty&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The things that we need to have by the end of the meshparty part:</span>

<span class="sd">        current_mesh_data[0][&quot;branch_meshes&quot;]</span>

<span class="sd">        Using:</span>
<span class="sd">        curr_limb_mesh = current_mesh_data[soma_containing_idx][&quot;branch_meshes&quot;][limb_idx]</span>

<span class="sd">        limb_correspondence[limb_idx][k][&quot;branch_mesh&quot;] = divided_submeshes[k]</span>
<span class="sd">        limb_correspondence[limb_idx][k][&quot;branch_face_idx&quot;] = divided_submeshes_idx[k]</span>

<span class="sd">        limb_correspondence[limb_idx][j][&quot;branch_skeleton&quot;] = curr_branch_sk</span>
<span class="sd">        limb_correspondence[limb_idx][j][&quot;width_from_skeleton&quot;] = width_from_skeleton</span>
<span class="sd">        </span>
<span class="sd">        Things to help you: </span>
<span class="sd">        -- helps with the connectivity (maps the somas limbs and the )</span>
<span class="sd">        soma_to_piece_connectivity[i] = connected_mesh_pieces</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        -- the actual meshes of the limbs</span>
<span class="sd">        current_mesh_data[0][&quot;branch_meshes&quot;]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="n">limb_correspondence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">total_skeletons</span> <span class="o">=</span>  <span class="p">[]</span>
        <span class="k">for</span> <span class="n">soma_containing_idx</span> <span class="ow">in</span> <span class="n">current_mesh_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">curr_limb_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="n">soma_containing_idx</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;------------Working on limb #</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">-------------&quot;</span><span class="p">)</span>
                <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                
                
                <span class="n">limb_mesh_mparty</span> <span class="o">=</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span>
                
                <span class="c1">#get a vertex to serve as the root node</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">limb_root_nodes</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Root for limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">root</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="c1"># Step 1: Getting the skeleton</span>
                
                <span class="n">limb_obj_tr_io</span>  <span class="o">=</span> <span class="n">trimesh_io</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                                       <span class="n">faces</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                                       <span class="n">normals</span><span class="o">=</span><span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">face_normals</span><span class="p">)</span>
                
                
        

                <span class="n">meshparty_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Step 1: Starting Skeletonization&quot;</span><span class="p">)</span>
                <span class="n">sk_meshparty_obj</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeletonize_mesh</span><span class="p">(</span><span class="n">limb_obj_tr_io</span><span class="p">,</span>
                                      <span class="n">soma_pt</span> <span class="o">=</span> <span class="n">root</span><span class="p">,</span>
                                      <span class="n">soma_radius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                      <span class="n">collapse_soma</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                      <span class="n">invalidation_d</span><span class="o">=</span><span class="mi">12000</span><span class="p">,</span>
                                      <span class="n">smooth_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">smooth_neighborhood</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                      <span class="n">compute_radius</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="c1">#Need the pyembree list</span>
                                      <span class="n">compute_original_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for meshParty skeletonization = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">meshparty_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="n">sk_meshparty</span> <span class="o">=</span> <span class="n">sk_meshparty_obj</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">sk_meshparty_obj</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>
                <span class="n">total_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk_meshparty</span><span class="p">)</span>
                
                
                
                <span class="k">if</span> <span class="n">mesh_correspondence</span> <span class="o">!=</span> <span class="s2">&quot;meshafterparty_adaptive&quot;</span><span class="p">:</span>
                    
                    <span class="c1">#Step 2: Getting the branches</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Step 2: Decomposing Branches&quot;</span><span class="p">)</span>
                    <span class="n">meshparty_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                    <span class="n">segments</span><span class="p">,</span> <span class="n">segment_maps</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">compute_segments</span><span class="p">(</span><span class="n">sk_meshparty_obj</span><span class="p">)</span>
                    <span class="c1"># getting the skeletons that go with them</span>
                    <span class="n">segment_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk_meshparty_obj</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>
                    
                    
                    <span class="c1">#------------ Add in the downsampling and resizing ----------------- #</span>
                    
                    
                    <span class="k">if</span> <span class="n">meshparty_n_surface_downsampling</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Going to downsample the meshparty segments </span><span class="si">{</span><span class="n">meshparty_n_surface_downsampling</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_surface_downsampling</span><span class="p">):</span>
                                <span class="n">s</span> <span class="o">=</span> <span class="n">downsample_skeleton</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="n">segment_branches</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                    
                    <span class="k">if</span> <span class="n">meshparty_segment_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resizing meshparty skeletal segments to length </span><span class="si">{</span><span class="n">meshparty_segment_size</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">):</span>
                            <span class="n">segment_branches</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">segment_width</span> <span class="o">=</span> <span class="n">meshparty_segment_size</span><span class="p">)</span>
                    
                    <span class="c1">#------------ END OF downsampling and resizing ----------------- #</span>


                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for meshParty decomposition = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">meshparty_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                    <span class="c1"># -- Step 3: Creating the mesh correspondence --</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Step 3: Mesh correspondence&quot;</span><span class="p">)</span>
                    <span class="n">meshparty_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                    <span class="n">sk_vertices_to_mesh_vertices</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">invert_mapping</span><span class="p">(</span><span class="n">sk_meshparty_obj</span><span class="o">.</span><span class="n">mesh_to_skel_map</span><span class="p">)</span>
                    <span class="c1">#getting a list of all the original vertices that belong to each segment</span>
                    <span class="n">segment_mesh_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sk_vertices_to_mesh_vertices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">segment_list</span><span class="p">]))</span> <span class="k">for</span> <span class="n">segment_list</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>
                    <span class="c1">#getting a list of all the original vertices that belong to each segment</span>
                    <span class="n">segment_mesh_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">vertex_faces</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">segment_mesh_vertices</span><span class="p">]</span>
                    <span class="n">segment_mesh_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">segment_mesh_faces</span><span class="p">]</span>

                    <span class="n">face_lookup</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">invert_mapping</span><span class="p">(</span><span class="n">segment_mesh_faces</span><span class="p">)</span>

                    <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span>


                    <span class="n">original_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">face_lookup</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(original_labels),len(original_labels) = </span><span class="si">{</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">original_labels</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">resolve_empty_conflicting_face_labels</span><span class="p">(</span><span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="p">,</span>
                                                                                <span class="n">face_lookup</span><span class="o">=</span><span class="n">face_lookup</span><span class="p">,</span>
                                                                                <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_labels</span><span class="p">))</span>


                    <span class="c1"># -- splitting the mesh pieces into individual pieces</span>
                    <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">face_coloring_copy</span><span class="p">)</span>

                    <span class="c1">#print(f&quot;divided_submeshes = {divided_submeshes}&quot;)</span>
                    <span class="c1">#print(f&quot;divided_submeshes_idx = {divided_submeshes_idx}&quot;)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for meshParty mesh correspondence = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">meshparty_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># -- Step 4: Getting the Widths ---</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Step 4: Retrieving Widths&quot;</span><span class="p">)</span>
                    <span class="n">meshparty_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                    <span class="n">segment_width_measurements</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk_meshparty_obj</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s2">&quot;rs&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>
                    <span class="n">segment_widths_median</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">segment_width_measurements</span><span class="p">]</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for meshParty Retrieving Widths = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">meshparty_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="c1"># ---- Our Final Products -----</span>

                    <span class="n">segment_branches</span> <span class="c1">#skeleton branches</span>

                    <span class="n">divided_submeshes</span><span class="p">,</span> <span class="n">divided_submeshes_idx</span> <span class="c1">#mesh correspondence (mesh and indices)</span>

                    <span class="n">segment_widths_median</span> <span class="c1">#widths</span>



                    <span class="n">output_data_flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branch </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> has 0 length&quot;</span><span class="p">)</span>
                            <span class="n">output_data_flag</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">branch segment sizes = </span><span class="si">{</span><span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">b</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">)])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
                    <span class="k">if</span> <span class="n">output_data_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;******* exporting the data for debugging *************&quot;</span><span class="p">)</span>
                        <span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">_mesh.off&quot;</span><span class="p">)</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="n">sk_meshparty_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;limb_</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">_sk_meshparty_obj&quot;</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">k</span><span class="p">,(</span><span class="n">sk_b</span><span class="p">,</span><span class="n">width_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">,</span>
                                                          <span class="n">segment_widths_median</span><span class="p">)):</span>
                        <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                        <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divided_submeshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

                        <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sk_b</span>
                        <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width_b</span>
                        
    <span class="c1">#-------------- Starting the adaptive mesh correspondence for the meshparty option (COPIED CODE FROM ABOVE) --------------------------------- #</span>
        <span class="k">if</span> <span class="n">mesh_correspondence</span> <span class="o">==</span> <span class="s2">&quot;meshafterparty_adaptive&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;****************** Using the adaptive mesh correspondence in the meshparty option ***************************&quot;</span><span class="p">)</span>
            <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_skeletons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_skeletons</span>
            <span class="n">limb_correspondence</span> <span class="o">=</span> <span class="n">further_mesh_correspondence_processing_from_skeleton</span><span class="p">(</span><span class="n">soma_touching_mesh_data</span><span class="p">,</span>
                                                                                      <span class="n">combine_close_skeleton_nodes</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes</span><span class="p">,</span>
                                                                                       <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                                                                                        <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="n">combine_close_skeleton_nodes_threshold</span><span class="p">)</span>
            
            
            
            
    <span class="c1">#---------------------------------------------- STOPPING the adaptive mesh correspondence for the meshparty option --------------------------------- #</span>

<span class="c1"># --------------------------------- where END with meshparty option ------------------------------------------------ #</span>


    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid decomposition type chosen: </span><span class="si">{</span><span class="n">decomposition_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Visualizing the results of getting the mesh to skeletal segment correspondence completely 1-to-1</span>
    
<span class="c1">#     from matplotlib import pyplot as plt</span>
<span class="c1">#     fig,ax = plt.subplots(1,1)</span>
<span class="c1">#     bins = plt.hist(np.array(total_widths),bins=100)</span>
<span class="c1">#     ax.set_xlabel(&quot;Width measurement of mesh branch (nm)&quot;)</span>
<span class="c1">#     ax.set_ylabel(&quot;frequency&quot;)</span>
<span class="c1">#     ax.set_title(&quot;Width measurement of mesh branch frequency&quot;)</span>
<span class="c1">#     plt.show()</span>
    
<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes=total_branch_meshes,</span>
<span class="c1">#                           other_meshes_colors=&quot;random&quot;,</span>
<span class="c1">#                           other_skeletons=total_branch_skeletons,</span>
<span class="c1">#                           other_skeletons_colors=&quot;random&quot;,</span>
<span class="c1">#                           #html_path=&quot;two_soma_mesh_skeleton_decomp.html&quot;</span>
<span class="c1">#                           )</span>

    
<span class="c1">#     sk.graph_skeleton_and_mesh(other_meshes=[total_branch_meshes[47]],</span>
<span class="c1">#                               other_meshes_colors=&quot;random&quot;,</span>
<span class="c1">#                               other_skeletons=[total_branch_skeletons[47]],</span>
<span class="c1">#                               other_skeletons_colors=&quot;random&quot;,</span>
<span class="c1">#                               html_path=&quot;two_soma_mesh_skeleton_decomp.html&quot;)</span>
    
    
    
    
    
    
    
    
    
    
    
    <span class="c1"># ********************   Phase C ***************************************</span>
    <span class="c1"># PART 3: LAST PART OF ANALYSIS WHERE MAKES CONCEPT GRAPHS</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\n\n\n</span><span class="s2">****** Phase C ***************</span><span class="se">\n\n\n\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    
    
    
    <span class="c1"># ---1) Making concept graphs:</span>

    <span class="n">limb_concept_networks</span><span class="p">,</span><span class="n">limb_labels</span> <span class="o">=</span> <span class="n">generate_limb_concept_networks_from_global_connectivity</span><span class="p">(</span>
        <span class="n">limb_correspondence</span> <span class="o">=</span> <span class="n">limb_correspondence</span><span class="p">,</span>
        <span class="c1">#limb_idx_to_branch_meshes_dict = limb_idx_to_branch_meshes_dict,</span>
        <span class="c1">#limb_idx_to_branch_skeletons_dict = limb_idx_to_branch_skeletons_dict,</span>
        
        <span class="n">soma_meshes</span><span class="o">=</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">],</span>
        <span class="n">soma_idx_connectivity</span><span class="o">=</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">],</span>
        <span class="n">limb_to_soma_starting_endpoints</span> <span class="o">=</span> <span class="n">endpoints_must_keep</span><span class="p">,</span>
        <span class="c1">#soma_idx_to_mesh_dict = soma_idx_to_mesh_dict,</span>
        <span class="c1">#soma_idx_connectivity = soma_idx_connectivity,</span>
        
        <span class="n">current_neuron</span><span class="o">=</span><span class="n">current_neuron</span><span class="p">,</span>
        <span class="n">return_limb_labels</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

<span class="c1">#     #Before go and get concept maps:</span>
<span class="c1">#     print(&quot;Sizes of dictionaries sent&quot;)</span>
<span class="c1">#     for curr_limb in limb_idx_to_branch_skeletons_dict.keys():</span>
<span class="c1">#         print((len(limb_idx_to_branch_skeletons_dict[curr_limb]),len(limb_idx_to_branch_meshes_dict[curr_limb])))</span>


<span class="c1">#     print(&quot;\n\n Sizes of concept maps gotten back&quot;)</span>
<span class="c1">#     for curr_idx in limb_concept_networks.keys():</span>
<span class="c1">#         for soma_idx,concept_network in limb_concept_networks[curr_idx].items():</span>
<span class="c1">#             print(len(np.unique(list(concept_network.nodes()))))</span>
            
    
    
    
    
    
    
    
    
    

    
    <span class="c1"># ---2) Packaging the data into a dictionary that can be sent to the Neuron class to create the object</span>
    
    <span class="c1">#Preparing the data structure to save or use for Neuron class construction</span>

<span class="c1">#     sk_debug = True</span>
<span class="c1">#     if sk_debug:</span>
<span class="c1">#         from python_tools import system_utils as su</span>
<span class="c1">#         su.compressed_pickle(limb_correspondence,</span>
<span class="c1">#                             &quot;fourth_original_limb_correspondence&quot;)</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; 9/17 Addition: No longer doing limb split because do not require it&quot;&quot;&quot;</span>
    
    <span class="n">perform_limb_split</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">perform_limb_split</span><span class="p">:</span>
        <span class="c1">#Old way of getting the processed data</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NOT USING THE LIMB SPLITTING ALGORITHM&quot;</span><span class="p">)</span>
        <span class="n">preprocessed_data</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                                <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">],</span>
                                <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">],</span>
                                <span class="n">soma_sdfs</span> <span class="o">=</span> <span class="n">total_soma_list_sdf</span><span class="p">,</span>
                                <span class="n">insignificant_limbs</span><span class="o">=</span><span class="n">insignificant_limbs</span><span class="p">,</span>
                                <span class="n">non_soma_touching_meshes</span><span class="o">=</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                <span class="n">inside_pieces</span><span class="o">=</span><span class="n">inside_pieces</span><span class="p">,</span>
                                <span class="n">limb_correspondence</span><span class="o">=</span><span class="n">limb_correspondence</span><span class="p">,</span>
                                <span class="n">limb_concept_networks</span><span class="o">=</span><span class="n">limb_concept_networks</span><span class="p">,</span>
                                <span class="n">limb_labels</span><span class="o">=</span><span class="n">limb_labels</span><span class="p">,</span>
                                <span class="n">limb_meshes</span><span class="o">=</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">],</span>
                                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;USING THE LIMB SPLITTING ALGORITHM&quot;</span><span class="p">)</span>

        <span class="c1"># ------------- Post-Processing: Will now do the limb splitting if need ----------------- #</span>
        <span class="n">limb_concept_networks</span><span class="o">=</span><span class="n">limb_concept_networks</span>
        <span class="n">limb_meshes</span><span class="o">=</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]</span>

        <span class="c1">#make the limb objects</span>
        <span class="n">new_limb_objs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">curr_limb_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]):</span>
            <span class="n">new_curr_limb</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">(</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="p">,</span>
                                           <span class="n">curr_limb_correspondence</span><span class="o">=</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">],</span>
                                           <span class="n">concept_network_dict</span><span class="o">=</span><span class="n">limb_concept_networks</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">])</span>
            <span class="n">new_limb_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_curr_limb</span><span class="p">)</span>


        <span class="c1">#need to run the function</span>
        <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]</span>
        <span class="n">current_neuron_mesh</span> <span class="o">=</span> <span class="n">current_neuron</span>


    <span class="c1">#     from python_tools import system_utils as su</span>
    <span class="c1">#     su.compressed_pickle(new_limb_objs,</span>
    <span class="c1">#                         filename=&quot;new_limb_objs&quot;)</span>
    <span class="c1">#     su.compressed_pickle(soma_meshes,</span>
    <span class="c1">#                         filename=&quot;soma_meshes&quot;)</span>
    <span class="c1">#     su.compressed_pickle(current_neuron,</span>
    <span class="c1">#                         filename=&quot;current_neuron&quot;)</span>
    <span class="c1">#     su.compressed_pickle(limb_concept_networks,</span>
    <span class="c1">#                         filename=&quot;limb_concept_networks&quot;)</span>
    <span class="c1">#     su.compressed_pickle(limb_concept_networks,</span>
    <span class="c1">#                         filename=&quot;limb_concept_networks&quot;)</span>


        <span class="c1">#send the new data to the function</span>
        <span class="p">(</span><span class="n">new_limb_correspondence</span><span class="p">,</span>
         <span class="n">new_soma_to_piece_connectivity</span><span class="p">,</span>
         <span class="n">new_limb_meshes</span><span class="p">,</span>
         <span class="n">new_limb_concept_networks</span><span class="p">,</span>
         <span class="n">new_limb_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">limb_split</span><span class="p">(</span><span class="n">limbs</span><span class="o">=</span><span class="n">new_limb_objs</span><span class="p">,</span>
                                          <span class="n">soma_meshes</span><span class="o">=</span><span class="n">soma_meshes</span><span class="p">,</span>
                                          <span class="n">current_neuron_mesh</span><span class="o">=</span><span class="n">current_neuron</span><span class="p">)</span>

    <span class="c1">#     if sk_debug:</span>
    <span class="c1">#         from python_tools import system_utils as su</span>
    <span class="c1">#         su.compressed_pickle(new_limb_correspondence,</span>
    <span class="c1">#                             &quot;fifth_new_limb_correspondence&quot;)</span>
        <span class="n">preprocessed_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                                <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">],</span>
                                <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="n">new_soma_to_piece_connectivity</span><span class="p">,</span>
                                <span class="n">soma_sdfs</span> <span class="o">=</span> <span class="n">total_soma_list_sdf</span><span class="p">,</span>
                                <span class="n">insignificant_limbs</span><span class="o">=</span><span class="n">insignificant_limbs</span><span class="p">,</span>
                                <span class="n">non_soma_touching_meshes</span><span class="o">=</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                <span class="n">inside_pieces</span><span class="o">=</span><span class="n">inside_pieces</span><span class="p">,</span>
                                <span class="n">limb_correspondence</span><span class="o">=</span><span class="n">new_limb_correspondence</span><span class="p">,</span>
                                <span class="n">limb_concept_networks</span><span class="o">=</span><span class="n">new_limb_concept_networks</span><span class="p">,</span>
                                <span class="n">limb_labels</span><span class="o">=</span><span class="n">new_limb_labels</span><span class="p">,</span>
                                <span class="n">limb_meshes</span><span class="o">=</span><span class="n">new_limb_meshes</span>
                                <span class="p">)</span>

    


    
    
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2"> Total processing time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">whole_processing_tiempo</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;returning preprocessed_data = {preprocessed_data}&quot;)</span>
    <span class="k">return</span> <span class="n">preprocessed_data</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def preprocess_neuron_OLD(mesh=None,</span>
<span class="sd">                     mesh_file=None,</span>
<span class="sd">                     segment_id=None,</span>
<span class="sd">                     description=None,</span>
<span class="sd">                     sig_th_initial_split=15, #for significant splitting meshes in the intial mesh split</span>
<span class="sd">                     limb_threshold = 2000, #the mesh faces threshold for a mesh to be qualified as a limb (otherwise too small)</span>
<span class="sd">                      filter_end_node_length=5000, #used in cleaning the skeleton during skeletonizations</span>
<span class="sd">                      return_no_somas = False</span>
<span class="sd">                     ):</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    whole_processing_tiempo = time.time()</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To process the mesh into a format that can be loaded into the neuron class</span>
<span class="sd">    and used for higher order processing (how to visualize is included)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    if description is None:</span>
<span class="sd">        description = &quot;no_description&quot;</span>
<span class="sd">    if segment_id is None:</span>
<span class="sd">        #pick a random segment id</span>
<span class="sd">        segment_id = np.random.randint(100000000)</span>
<span class="sd">        print(f&quot;picking a random 7 digit segment id: {segment_id}&quot;)</span>
<span class="sd">        description += &quot;_random_id&quot;</span>

<span class="sd">    </span>
<span class="sd">    if mesh is None:</span>
<span class="sd">        if current_mesh_file is None:</span>
<span class="sd">            raise Exception(&quot;No mesh or mesh_file file were given&quot;)</span>
<span class="sd">        else:</span>
<span class="sd">            current_neuron = trimesh.load_mesh(current_mesh_file)</span>
<span class="sd">    else:</span>
<span class="sd">        current_neuron = mesh</span>
<span class="sd">        </span>
<span class="sd">    # ************************ Phase A ********************************</span>
<span class="sd">    </span>
<span class="sd">    print(&quot;\n\n\n\n\n****** Phase A ***************\n\n\n\n\n&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # --- 1) Doing the soma detection</span>
<span class="sd">    </span>
<span class="sd">    soma_mesh_list,run_time,total_soma_list_sdf = sm.extract_soma_center(segment_id,</span>
<span class="sd">                                             current_neuron.vertices,</span>
<span class="sd">                                             current_neuron.faces)</span>
<span class="sd">    </span>
<span class="sd">    # geting the soma centers</span>
<span class="sd">    if len(soma_mesh_list) &lt;= 0:</span>
<span class="sd">        print(f&quot;**** No Somas Found for Mesh {segment_id} so just one mesh&quot;)</span>
<span class="sd">        soma_mesh_list_centers = []</span>
<span class="sd">        if return_no_somas:</span>
<span class="sd">            return soma_mesh_list_centers</span>
<span class="sd">        raise Exception(&quot;Processing of No Somas is not yet implemented yet&quot;)</span>
<span class="sd">    else:</span>
<span class="sd">        #compute the soma centers</span>
<span class="sd">        print(f&quot;Soma List = {soma_mesh_list}&quot;)</span>

<span class="sd">        soma_mesh_list_centers = sm.find_soma_centroids(soma_mesh_list)</span>
<span class="sd">        print(f&quot;soma_mesh_list_centers = {soma_mesh_list_centers}&quot;)</span>
<span class="sd">    </span>
<span class="sd">#     sk.graph_skeleton_and_mesh(main_mesh_verts=current_neuron.vertices,</span>
<span class="sd">#                           main_mesh_faces=current_neuron.faces,</span>
<span class="sd">#                            main_mesh_color = [0.,1.,0.,0.8]</span>
<span class="sd">#                           )</span>

<span class="sd">    # ********At this point assume that there are somas (if not would just skip to the limb skeleton stuff) *******</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    #--- 2) getting the soma submeshes that are connected to each soma and identifiying those that aren&#39;t (and eliminating any mesh pieces inside the soma)</span>
<span class="sd">    </span>
<span class="sd">    main_mesh_total = current_neuron</span>
<span class="sd">    </span>

<span class="sd">    #finding the mesh pieces that contain the soma</span>
<span class="sd">    #splitting the current neuron into distinct pieces</span>
<span class="sd">    split_meshes = tu.split_significant_pieces(</span>
<span class="sd">                                main_mesh_total,</span>
<span class="sd">                                significance_threshold=sig_th_initial_split,</span>
<span class="sd">                                print_flag=False)</span>

<span class="sd">    print(f&quot;# total split meshes = {len(split_meshes)}&quot;)</span>


<span class="sd">    #returns the index of the split_meshes index that contains each soma    </span>
<span class="sd">    containing_mesh_indices = sm.find_soma_centroid_containing_meshes(soma_mesh_list,</span>
<span class="sd">                                            split_meshes)</span>
<span class="sd">    </span>
<span class="sd">    # filtering away any of the inside floating pieces: </span>
<span class="sd">    non_soma_touching_meshes = [m for i,m in enumerate(split_meshes)</span>
<span class="sd">                     if i not in list(containing_mesh_indices.values())]</span>


<span class="sd">    #Adding the step that will filter away any pieces that are inside the soma</span>
<span class="sd">    if len(non_soma_touching_meshes) &gt; 0 and len(soma_mesh_list) &gt; 0:</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        *** want to save these pieces that are inside of the soma***</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="sd">        non_soma_touching_meshes,inside_pieces = sm.filter_away_inside_soma_pieces(soma_mesh_list,non_soma_touching_meshes,</span>
<span class="sd">                                        significance_threshold=sig_th_initial_split,</span>
<span class="sd">                                        return_inside_pieces = True)                                                      </span>


<span class="sd">    split_meshes # the meshes of the original mesh</span>
<span class="sd">    containing_mesh_indices #the mapping of each soma centroid to the correct split mesh</span>
<span class="sd">    soma_containing_meshes = sm.grouping_containing_mesh_indices(containing_mesh_indices)</span>

<span class="sd">    soma_touching_meshes = [split_meshes[k] for k in soma_containing_meshes.keys()]</span>


<span class="sd">    print(f&quot;# of non soma touching seperate meshes = {len(non_soma_touching_meshes)}&quot;)</span>
<span class="sd">    print(f&quot;# of inside pieces = {len(inside_pieces)}&quot;)</span>
<span class="sd">    print(f&quot;# of soma containing seperate meshes = {len(soma_touching_meshes)}&quot;)</span>
<span class="sd">    print(f&quot;meshes with somas = {soma_containing_meshes}&quot;)</span>

<span class="sd">   </span>
<span class="sd">    </span>

<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    #--- 3)  Soma Extraction was great (but it wasn&#39;t the original soma faces), so now need to get the original soma faces and the original non-soma faces of original pieces</span>
<span class="sd">    </span>
<span class="sd">#     sk.graph_skeleton_and_mesh(other_meshes=[soma_meshes])</span>

<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    for each soma touching mesh get the following:</span>
<span class="sd">    1) original soma meshes</span>
<span class="sd">    2) significant mesh pieces touching these somas</span>
<span class="sd">    3) The soma connectivity to each of the significant mesh pieces</span>
<span class="sd">    -- later will just translate the </span>


<span class="sd">    Process: </span>

<span class="sd">    1) Final all soma faces (through soma extraction and then soma original faces function)</span>
<span class="sd">    2) Subtact all soma faces from original mesh</span>
<span class="sd">    3) Find all significant mesh pieces</span>
<span class="sd">    4) Backtrack significant mesh pieces to orignal mesh and find connectivity of each to all</span>
<span class="sd">       the available somas</span>
<span class="sd">    Conclusion: Will have connectivity map</span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    soma_touching_mesh_data = dict()</span>

<span class="sd">    for z,(mesh_idx, soma_idxes) in enumerate(soma_containing_meshes.items()):</span>
<span class="sd">        soma_touching_mesh_data[z] = dict()</span>
<span class="sd">        print(&quot;\n\n----Working on soma-containing mesh piece {z}----&quot;)</span>

<span class="sd">        #1) Final all soma faces (through soma extraction and then soma original faces function)</span>
<span class="sd">        current_mesh = split_meshes[mesh_idx]</span>

<span class="sd">        current_soma_mesh_list = [soma_mesh_list[k] for k in soma_idxes]</span>

<span class="sd">        current_time = time.time()</span>
<span class="sd">        mesh_pieces_without_soma = sm.subtract_soma(current_soma_mesh_list,current_mesh,</span>
<span class="sd">                                                    significance_threshold=250)</span>
<span class="sd">        print(f&quot;Total time for Subtract Soam = {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>

<span class="sd">        mesh_pieces_without_soma_stacked = tu.combine_meshes(mesh_pieces_without_soma)</span>

<span class="sd">        # find the original soma faces of mesh</span>
<span class="sd">        soma_faces = tu.original_mesh_faces_map(current_mesh,mesh_pieces_without_soma_stacked,matching=False)</span>
<span class="sd">        print(f&quot;Total time for Original_mesh_faces_map for mesh_pieces without soma= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>
<span class="sd">        soma_meshes = current_mesh.submesh([soma_faces],append=True)</span>

<span class="sd">        # finding the non-soma original faces</span>
<span class="sd">        non_soma_faces = tu.original_mesh_faces_map(current_mesh,soma_meshes,matching=False)</span>
<span class="sd">        non_soma_stacked_mesh = current_mesh.submesh([non_soma_faces],append=True)</span>

<span class="sd">        print(f&quot;Total time for Original_mesh_faces_map for somas= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>

<span class="sd">        # 3) Find all significant mesh pieces</span>
<span class="sd">        sig_non_soma_pieces,insignificant_limbs = tu.split_significant_pieces(non_soma_stacked_mesh,significance_threshold=limb_threshold,</span>
<span class="sd">                                                         return_insignificant_pieces=True)</span>

<span class="sd">        print(f&quot;Total time for sig_non_soma_pieces= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>

<span class="sd">        soma_touching_mesh_data[z][&quot;branch_meshes&quot;] = sig_non_soma_pieces</span>

<span class="sd">        #4) Backtrack significant mesh pieces to orignal mesh and find connectivity of each to all the available somas</span>
<span class="sd">        # get all the seperate mesh faces</span>

<span class="sd">        #How to seperate the mesh faces</span>
<span class="sd">        seperate_soma_meshes,soma_face_components = tu.split(soma_meshes,only_watertight=False)</span>
<span class="sd">        #take the top largest ones depending how many were originally in the soma list</span>
<span class="sd">        seperate_soma_meshes = seperate_soma_meshes[:len(soma_mesh_list)]</span>
<span class="sd">        soma_face_components = soma_face_components[:len(soma_mesh_list)]</span>

<span class="sd">        soma_touching_mesh_data[z][&quot;soma_meshes&quot;] = seperate_soma_meshes</span>

<span class="sd">        print(f&quot;Total time for split= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>



<span class="sd">        soma_to_piece_connectivity = dict()</span>
<span class="sd">        for i,curr_soma in enumerate(seperate_soma_meshes):</span>
<span class="sd">            connected_mesh_pieces,connected_mesh_pieces_vertices  = tu.mesh_pieces_connectivity(</span>
<span class="sd">                            main_mesh=current_mesh,</span>
<span class="sd">                            central_piece=curr_soma,</span>
<span class="sd">                            periphery_pieces = sig_non_soma_pieces,</span>
<span class="sd">                            return_vertices = True)</span>
<span class="sd">            #print(f&quot;soma {i}: connected_mesh_pieces = {connected_mesh_pieces}&quot;)</span>
<span class="sd">            soma_to_piece_connectivity[i] = connected_mesh_pieces</span>

<span class="sd">        print(f&quot;Total time for mesh_pieces_connectivity= {time.time() - current_time}&quot;)</span>

<span class="sd">        soma_touching_mesh_data[z][&quot;soma_to_piece_connectivity&quot;] = soma_to_piece_connectivity</span>

<span class="sd">    print(f&quot;# of insignificant_limbs = {len(insignificant_limbs)} with trimesh : {insignificant_limbs}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # Lets have an alert if there was more than one soma disconnected meshes</span>
<span class="sd">    if len(soma_touching_mesh_data.keys()) &gt; 1:</span>
<span class="sd">        raise Exception(&quot;More than 1 disconnected meshes that contain somas&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # ****Soma Touching mesh Data has the branches and the connectivity (So this is where you end up skipping if you don&#39;t have somas)***</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # ---5) Working on the Actual skeleton of all of the branches</span>

<span class="sd">    </span>
<span class="sd">    global_start_time = time.time()</span>

<span class="sd">    for j,(soma_containing_mesh_idx,mesh_data) in enumerate(soma_touching_mesh_data.items()):</span>
<span class="sd">        print(f&quot;\n-- Working on Soma Continaing Mesh {j}--&quot;)</span>
<span class="sd">        current_branches = mesh_data[&quot;branch_meshes&quot;]</span>

<span class="sd">        #skeletonize each of the branches</span>
<span class="sd">        total_skeletons = []</span>

<span class="sd">        for z,branch in enumerate(current_branches):</span>
<span class="sd">            print(f&quot;\n    -- Working on branch {z}--&quot;)</span>
<span class="sd">            curren_skeleton = sk.skeletonize_connected_branch(branch)</span>
<span class="sd">            #clean the skeleton</span>
<span class="sd">                # --------  Doing the cleaning ------- #</span>
<span class="sd">            clean_time = time.time()</span>
<span class="sd">            </span>
<span class="sd">            new_cleaned_skeleton = sk.clean_skeleton(curren_skeleton,</span>
<span class="sd">                                    distance_func=sk.skeletal_distance,</span>
<span class="sd">                              min_distance_to_junction=filter_end_node_length, #this used to be a tuple i think when moved the parameter up to function defintion</span>
<span class="sd">                              return_skeleton=True,</span>
<span class="sd">                              print_flag=False)</span>
<span class="sd">            print(f&quot;    Total time for skeleton and cleaning of branch {z}: {time.time() - clean_time}&quot;)</span>
<span class="sd">            if len(new_cleaned_skeleton) == 0:</span>
<span class="sd">                raise Exception(f&quot;Found a zero length skeleton for limb {z} of trmesh {branch}&quot;)</span>
<span class="sd">            total_skeletons.append(new_cleaned_skeleton)</span>

<span class="sd">        soma_touching_mesh_data[j][&quot;branch_skeletons&quot;] = total_skeletons</span>

<span class="sd">    print(f&quot;Total time for skeletonization = {time.time() - global_start_time}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # *************** Phase B *****************</span>
<span class="sd">    </span>
<span class="sd">    print(&quot;\n\n\n\n\n****** Phase B ***************\n\n\n\n\n&quot;)</span>
<span class="sd">    </span>
<span class="sd">    current_mesh_data = soma_touching_mesh_data</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # visualizing the original neuron</span>
<span class="sd">#     current_neuron = trimesh.load_mesh(current_mesh_file)</span>
<span class="sd">#     sk.graph_skeleton_and_mesh(main_mesh_verts=current_neuron.vertices,</span>
<span class="sd">#                               main_mesh_faces=current_neuron.faces,</span>
<span class="sd">#                                main_mesh_color = [0.,1.,0.,0.8]</span>
<span class="sd">#                               )</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # visualizing the somas that were extracted</span>
<span class="sd">#     soma_meshes = tu.combine_meshes(current_mesh_data[0][&quot;soma_meshes&quot;])</span>
<span class="sd">#     sk.graph_skeleton_and_mesh(main_mesh_verts=soma_meshes.vertices,</span>
<span class="sd">#                               main_mesh_faces=soma_meshes.faces,</span>
<span class="sd">#                                main_mesh_color = [0.,1.,0.,0.8]</span>
<span class="sd">#                               )</span>


<span class="sd">    # # Visualize the extracted branches</span>
<span class="sd">    # # visualize all of the branches and the meshes</span>
<span class="sd">    # sk.graph_skeleton_and_mesh(other_meshes=list(current_mesh_data[0][&quot;branch_meshes&quot;]) + list(current_mesh_data[0][&quot;soma_meshes&quot;]),</span>
<span class="sd">    #                           other_meshes_colors=&quot;random&quot;,</span>
<span class="sd">    #                            other_skeletons = current_mesh_data[0][&quot;branch_skeletons&quot;],</span>
<span class="sd">    #                           other_skeletons_colors=&quot;random&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    #--- 1) Cleaning each limb through distance and decomposition, checking that all cleaned branches are connected components and then visualizing</span>
<span class="sd">    </span>
<span class="sd">    skelton_cleaning_threshold = 4001</span>
<span class="sd">    total_cleaned = []</span>
<span class="sd">    for j,curr_skeleton_to_clean in enumerate(current_mesh_data[0][&quot;branch_skeletons&quot;]):</span>
<span class="sd">        print(f&quot;\n---- Working on Limb {j} ----&quot;)</span>
<span class="sd">        start_time = time.time()</span>
<span class="sd">        print(f&quot;before cleaning limb size of skeleton = {curr_skeleton_to_clean.shape}&quot;)</span>
<span class="sd">        distance_cleaned_skeleton = sk.clean_skeleton(</span>
<span class="sd">                                                    curr_skeleton_to_clean,</span>
<span class="sd">                                                    distance_func=sk.skeletal_distance,</span>
<span class="sd">                                                    min_distance_to_junction = skelton_cleaning_threshold,</span>
<span class="sd">                                                    return_skeleton=True,</span>
<span class="sd">                                                    print_flag=False) </span>
<span class="sd">        #make sure still connected componet</span>
<span class="sd">        distance_cleaned_skeleton_components = nx.number_connected_components(sk.convert_skeleton_to_graph(distance_cleaned_skeleton))</span>
<span class="sd">        if distance_cleaned_skeleton_components &gt; 1:</span>
<span class="sd">            raise Exception(f&quot;distance_cleaned_skeleton {j} was not a single component: it was actually {distance_cleaned_skeleton_components} components&quot;)</span>

<span class="sd">        print(f&quot;after DISTANCE cleaning limb size of skeleton = {distance_cleaned_skeleton.shape}&quot;)</span>
<span class="sd">        cleaned_branch = sk.clean_skeleton_with_decompose(distance_cleaned_skeleton)</span>

<span class="sd">        cleaned_branch_components = nx.number_connected_components(sk.convert_skeleton_to_graph(cleaned_branch))</span>
<span class="sd">        if cleaned_branch_components &gt; 1:</span>
<span class="sd">            raise Exception(f&quot;cleaned_branch {j} was not a single component: it was actually {cleaned_branch_components} components&quot;)</span>

<span class="sd">        #do the cleanin ghtat removes loops from branches</span>
<span class="sd">        print(f&quot;After DECOMPOSITION cleaning limb size of skeleton = {cleaned_branch.shape}&quot;)</span>
<span class="sd">        print(f&quot;Total time = {time.time() - start_time}&quot;)</span>
<span class="sd">        total_cleaned.append(cleaned_branch)</span>

<span class="sd">    current_mesh_data[0][&quot;branch_skeletons_cleaned&quot;] = total_cleaned</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # checking all cleaned branches are connected components</span>

<span class="sd">    for k,cl_sk in enumerate(current_mesh_data[0][&quot;branch_skeletons&quot;]): </span>
<span class="sd">        n_components = nx.number_connected_components(sk.convert_skeleton_to_graph(cl_sk)) </span>
<span class="sd">        if n_components &gt; 1:</span>
<span class="sd">            raise Exception(f&quot;Original limb {k} was not a single component: it was actually {n_components} components&quot;)</span>

<span class="sd">    for k,cl_sk in enumerate(current_mesh_data[0][&quot;branch_skeletons_cleaned&quot;]): </span>
<span class="sd">        n_components = nx.number_connected_components(sk.convert_skeleton_to_graph(cl_sk)) </span>
<span class="sd">        if n_components &gt; 1:</span>
<span class="sd">            raise Exception(f&quot;Cleaned limb {k} was not a single component: it was actually {n_components} components&quot;)</span>
<span class="sd">            </span>
<span class="sd">    </span>
<span class="sd">    # # visualize all of the branches and the meshes</span>
<span class="sd">    # sk.graph_skeleton_and_mesh(other_meshes=list(current_mesh_data[0][&quot;branch_meshes&quot;]) + list(current_mesh_data[0][&quot;soma_meshes&quot;]),</span>
<span class="sd">    #                           other_meshes_colors=&quot;random&quot;,</span>
<span class="sd">    #                            other_skeletons = current_mesh_data[0][&quot;branch_skeletons_cleaned&quot;],</span>
<span class="sd">    #                           other_skeletons_colors=&quot;random&quot;,</span>
<span class="sd">    #                           mesh_alpha=0.15,</span>
<span class="sd">    #                           html_path=f&quot;{segment_id}_limb_skeleton.html&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # --- 2) Decomposing of limbs into branches and finding mesh correspondence (using adaptive mesh correspondence followed by a water fill for conflict and empty faces), checking that it went well with no empty meshes and all connected component graph (even when downsampling the skeleton) when constructed from branches, plus visualization at end</span>
<span class="sd">    </span>
<span class="sd">    </span>

<span class="sd">    start_time = time.time()</span>

<span class="sd">    limb_correspondence = dict()</span>
<span class="sd">    soma_containing_idx= 0</span>

<span class="sd">    for soma_containing_idx in current_mesh_data.keys():</span>
<span class="sd">        for limb_idx,curr_limb_mesh in enumerate(current_mesh_data[soma_containing_idx][&quot;branch_meshes&quot;]):</span>
<span class="sd">            print(f&quot;Working on limb #{limb_idx}&quot;)</span>
<span class="sd">            limb_correspondence[limb_idx] = dict()</span>
<span class="sd">            curr_limb_sk = current_mesh_data[soma_containing_idx][&quot;branch_skeletons_cleaned&quot;][limb_idx]</span>
<span class="sd">            curr_limb_branches_sk_uneven = sk.decompose_skeleton_to_branches(curr_limb_sk) #the line that is decomposing to branches</span>

<span class="sd">            for j,curr_branch_sk in tqdm(enumerate(curr_limb_branches_sk_uneven)):</span>
<span class="sd">                limb_correspondence[limb_idx][j] = dict()</span>


<span class="sd">                curr_branch_face_correspondence, width_from_skeleton = cu.mesh_correspondence_adaptive_distance(curr_branch_sk,</span>
<span class="sd">                                              curr_limb_mesh,</span>
<span class="sd">                                             skeleton_segment_width = 1000)</span>



<span class="sd">                if len(curr_branch_face_correspondence) &gt; 0:</span>
<span class="sd">                    curr_submesh = curr_limb_mesh.submesh([list(curr_branch_face_correspondence)],append=True)</span>
<span class="sd">                else:</span>
<span class="sd">                    curr_submesh = trimesh.Trimesh(vertices=np.array([]),faces=np.array([]))</span>

<span class="sd">                limb_correspondence[limb_idx][j][&quot;branch_skeleton&quot;] = curr_branch_sk</span>
<span class="sd">                limb_correspondence[limb_idx][j][&quot;correspondence_mesh&quot;] = curr_submesh</span>
<span class="sd">                limb_correspondence[limb_idx][j][&quot;correspondence_face_idx&quot;] = curr_branch_face_correspondence</span>
<span class="sd">                limb_correspondence[limb_idx][j][&quot;width_from_skeleton&quot;] = width_from_skeleton</span>


<span class="sd">    print(f&quot;Total time for decomposition = {time.time() - start_time}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    #couple of checks on how the decomposition went:  for each limb</span>
<span class="sd">    #1) if shapes of skeletons cleaned and divided match</span>
<span class="sd">    #2) if skeletons are only one component</span>
<span class="sd">    #3) if you downsample the skeletons then still only one component</span>
<span class="sd">    #4) if any empty meshes</span>
<span class="sd">    </span>
<span class="sd">    empty_submeshes = []</span>

<span class="sd">    for soma_containing_idx in current_mesh_data.keys():</span>
<span class="sd">        for limb_idx,curr_limb_mesh in enumerate(current_mesh_data[soma_containing_idx][&quot;branch_meshes&quot;]):</span>
<span class="sd">            print(f&quot;\n---- checking limb {limb_idx}---&quot;)</span>
<span class="sd">            print(f&quot;Limb {limb_idx} decomposed into {len(limb_correspondence[limb_idx])} branches&quot;)</span>

<span class="sd">            #get all of the skeletons and make sure that they from a connected component</span>
<span class="sd">            divided_branches = [limb_correspondence[limb_idx][k][&quot;branch_skeleton&quot;] for k in limb_correspondence[limb_idx]]</span>
<span class="sd">            divided_skeleton_graph = sk.convert_skeleton_to_graph(</span>
<span class="sd">                                            sk.stack_skeletons(divided_branches))</span>

<span class="sd">            divided_skeleton_graph_recovered = sk.convert_graph_to_skeleton(divided_skeleton_graph)</span>

<span class="sd">            cleaned_limb_skeleton = current_mesh_data[0][&#39;branch_skeletons_cleaned&#39;][limb_idx]</span>
<span class="sd">            print(f&quot;divided_skeleton_graph_recovered = {divided_skeleton_graph_recovered.shape} and \n&quot;</span>
<span class="sd">                  f&quot;current_mesh_data[0][&#39;branch_skeletons_cleaned&#39;].shape = {cleaned_limb_skeleton.shape}\n&quot;)</span>
<span class="sd">            if divided_skeleton_graph_recovered.shape != cleaned_limb_skeleton.shape:</span>
<span class="sd">                print(f&quot;****divided_skeleton_graph_recovered and cleaned_limb_skeleton shapes not match: &quot;</span>
<span class="sd">                                f&quot;{divided_skeleton_graph_recovered.shape} vs. {cleaned_limb_skeleton.shape} *****&quot;)</span>


<span class="sd">            #check that it is all one component</span>
<span class="sd">            divided_skeleton_graph_n_comp = nx.number_connected_components(divided_skeleton_graph)</span>
<span class="sd">            print(f&quot;Number of connected components in deocmposed recovered graph = {divided_skeleton_graph_n_comp}&quot;)</span>

<span class="sd">            cleaned_limb_skeleton_graph = sk.convert_skeleton_to_graph(cleaned_limb_skeleton)</span>
<span class="sd">            cleaned_limb_skeleton_graph_n_comp = nx.number_connected_components(cleaned_limb_skeleton_graph)</span>
<span class="sd">            print(f&quot;Number of connected components in cleaned skeleton graph= {cleaned_limb_skeleton_graph_n_comp}&quot;)</span>

<span class="sd">            if divided_skeleton_graph_n_comp &gt; 1 or cleaned_limb_skeleton_graph_n_comp &gt; 1:</span>
<span class="sd">                raise Exception(f&quot;One of the decompose_skeletons or cleaned skeletons was not just one component : {divided_skeleton_graph_n_comp,cleaned_limb_skeleton_graph_n_comp}&quot;)</span>

<span class="sd">            #check that when we downsample it is not one component:</span>
<span class="sd">            curr_branch_meshes_downsampled = [sk.resize_skeleton_branch(b,n_segments=1) for b in divided_branches]</span>
<span class="sd">            downsampled_skeleton = sk.stack_skeletons(curr_branch_meshes_downsampled)</span>
<span class="sd">            curr_sk_graph_debug = sk.convert_skeleton_to_graph(downsampled_skeleton)</span>


<span class="sd">            con_comp = list(nx.connected_components(curr_sk_graph_debug))</span>
<span class="sd">            if len(con_comp) &gt; 1:</span>
<span class="sd">                raise Exception(f&quot;There were more than 1 component when downsizing: {[len(k) for k in con_comp]}&quot;)</span>
<span class="sd">            else:</span>
<span class="sd">                print(f&quot;The downsampled branches number of connected components = {len(con_comp)}&quot;)</span>


<span class="sd">            for j in limb_correspondence[limb_idx].keys():</span>
<span class="sd">                if len(limb_correspondence[limb_idx][j][&quot;correspondence_mesh&quot;].faces) == 0:</span>
<span class="sd">                    empty_submeshes.append(dict(limb_idx=limb_idx,branch_idx = j))</span>

<span class="sd">    print(f&quot;Empty submeshes = {empty_submeshes}&quot;)</span>

<span class="sd">    if len(empty_submeshes) &gt; 0:</span>
<span class="sd">        raise Exception(f&quot;Found empyt meshes after branch mesh correspondence: {empty_submeshes}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        </span>

<span class="sd">    # from python_tools import matplotlib_utils as mu</span>

<span class="sd">    # sk.graph_skeleton_and_mesh(other_meshes=total_branch_meshes,</span>
<span class="sd">    #                           other_meshes_colors=&quot;random&quot;,</span>
<span class="sd">    #                            other_skeletons=total_branch_skeletons,</span>
<span class="sd">    #                            other_skeletons_colors=&quot;random&quot;</span>
<span class="sd">    #                           )</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # ---3) Finishing off the face correspondence so get 1-to-1 correspondence of mesh face to skeletal piece</span>
<span class="sd">    </span>
<span class="sd">    #--- this is the function that will clean up a limb piece so have 1-1 correspondence</span>

<span class="sd">    #things to prep for visualizing the axons</span>
<span class="sd">#     total_widths = []</span>
<span class="sd">#     total_branch_skeletons = []</span>
<span class="sd">#     total_branch_meshes = []</span>

<span class="sd">    soma_containing_idx = 0</span>

<span class="sd">    for limb_idx in limb_correspondence.keys():</span>
<span class="sd">        mesh_start_time = time.time()</span>
<span class="sd">        #clear out the mesh correspondence if already in limb_correspondecne</span>
<span class="sd">        for k in limb_correspondence[limb_idx].keys():</span>
<span class="sd">            if &quot;branch_mesh&quot; in limb_correspondence[limb_idx][k]:</span>
<span class="sd">                del limb_correspondence[limb_idx][k][&quot;branch_mesh&quot;]</span>
<span class="sd">            if &quot;branch_face_idx&quot; in limb_correspondence[limb_idx][k]:</span>
<span class="sd">                del limb_correspondence[limb_idx][k][&quot;branch_face_idx&quot;]</span>
<span class="sd">        #geting the current limb mesh</span>
<span class="sd">        print(f&quot;\n\nWorking on limb_correspondence for #{limb_idx}&quot;)</span>
<span class="sd">        no_missing_labels = list(limb_correspondence[limb_idx].keys()) #counts the number of divided branches which should be the total number of labels</span>
<span class="sd">        curr_limb_mesh = current_mesh_data[soma_containing_idx][&quot;branch_meshes&quot;][limb_idx]</span>

<span class="sd">        #set up the face dictionary</span>
<span class="sd">        face_lookup = dict([(j,[]) for j in range(0,len(curr_limb_mesh.faces))])</span>

<span class="sd">        for j,branch_piece in limb_correspondence[limb_idx].items():</span>
<span class="sd">            curr_faces_corresponded = branch_piece[&quot;correspondence_face_idx&quot;]</span>

<span class="sd">            for c in curr_faces_corresponded:</span>
<span class="sd">                face_lookup[c].append(j)</span>

<span class="sd">        original_labels = set(list(itertools.chain.from_iterable(list(face_lookup.values()))))</span>
<span class="sd">        print(f&quot;max(original_labels),len(original_labels) = {(max(original_labels),len(original_labels))}&quot;)</span>


<span class="sd">        if len(original_labels) != len(no_missing_labels):</span>
<span class="sd">            raise Exception(f&quot;len(original_labels) != len(no_missing_labels) for original_labels = {len(original_labels)},no_missing_labels = {len(no_missing_labels)}&quot;)</span>

<span class="sd">        if max(original_labels) + 1 &gt; len(original_labels):</span>
<span class="sd">            raise Exception(&quot;There are some missing labels in the initial labeling&quot;)</span>



<span class="sd">        #here is where can call the function that resolves the face labels</span>
<span class="sd">        face_coloring_copy = cu.resolve_empty_conflicting_face_labels(</span>
<span class="sd">                         curr_limb_mesh = curr_limb_mesh,</span>
<span class="sd">                         face_lookup=face_lookup,</span>
<span class="sd">                         no_missing_labels = list(original_labels)</span>
<span class="sd">        )</span>


<span class="sd">        # -- splitting the mesh pieces into individual pieces</span>
<span class="sd">        divided_submeshes,divided_submeshes_idx = tu.split_mesh_into_face_groups(curr_limb_mesh,face_coloring_copy)</span>

<span class="sd">        #-- check that all the split mesh pieces are one component --#</span>

<span class="sd">        #save off the new data as branch mesh</span>
<span class="sd">        for k in limb_correspondence[limb_idx].keys():</span>
<span class="sd">            limb_correspondence[limb_idx][k][&quot;branch_mesh&quot;] = divided_submeshes[k]</span>
<span class="sd">            limb_correspondence[limb_idx][k][&quot;branch_face_idx&quot;] = divided_submeshes_idx[k]</span>
<span class="sd">            </span>
<span class="sd">            #clean the limb correspondence that we do not need</span>
<span class="sd">            del limb_correspondence[limb_idx][k][&quot;correspondence_mesh&quot;]</span>
<span class="sd">            del limb_correspondence[limb_idx][k][&quot;correspondence_face_idx&quot;]</span>
<span class="sd">#             total_widths.append(limb_correspondence[limb_idx][k][&quot;width_from_skeleton&quot;])</span>
<span class="sd">#             total_branch_skeletons.append(limb_correspondence[limb_idx][k][&quot;branch_skeleton&quot;])</span>
<span class="sd">#             total_branch_meshes.append(limb_correspondence[limb_idx][k][&quot;branch_mesh&quot;])</span>

<span class="sd">        print(f&quot;Total time for limb mesh processing = {time.time() - mesh_start_time}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # Visualizing the results of getting the mesh to skeletal segment correspondence completely 1-to-1</span>
<span class="sd">    </span>
<span class="sd">#     from matplotlib import pyplot as plt</span>
<span class="sd">#     fig,ax = plt.subplots(1,1)</span>
<span class="sd">#     bins = plt.hist(np.array(total_widths),bins=100)</span>
<span class="sd">#     ax.set_xlabel(&quot;Width measurement of mesh branch (nm)&quot;)</span>
<span class="sd">#     ax.set_ylabel(&quot;frequency&quot;)</span>
<span class="sd">#     ax.set_title(&quot;Width measurement of mesh branch frequency&quot;)</span>
<span class="sd">#     plt.show()</span>
<span class="sd">    </span>
<span class="sd">#     sk.graph_skeleton_and_mesh(other_meshes=total_branch_meshes,</span>
<span class="sd">#                           other_meshes_colors=&quot;random&quot;,</span>
<span class="sd">#                           other_skeletons=total_branch_skeletons,</span>
<span class="sd">#                           other_skeletons_colors=&quot;random&quot;,</span>
<span class="sd">#                           #html_path=&quot;two_soma_mesh_skeleton_decomp.html&quot;</span>
<span class="sd">#                           )</span>

<span class="sd">    </span>
<span class="sd">#     sk.graph_skeleton_and_mesh(other_meshes=[total_branch_meshes[47]],</span>
<span class="sd">#                               other_meshes_colors=&quot;random&quot;,</span>
<span class="sd">#                               other_skeletons=[total_branch_skeletons[47]],</span>
<span class="sd">#                               other_skeletons_colors=&quot;random&quot;,</span>
<span class="sd">#                               html_path=&quot;two_soma_mesh_skeleton_decomp.html&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # ********************   Phase C ***************************************</span>
<span class="sd">    # PART 3: LAST PART OF ANALYSIS WHERE MAKES CONCEPT GRAPHS</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    print(&quot;\n\n\n\n\n****** Phase C ***************\n\n\n\n\n&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # ---1) Making concept graphs:</span>

<span class="sd">    limb_concept_networks,limb_labels = generate_limb_concept_networks_from_global_connectivity(</span>
<span class="sd">        limb_correspondence = limb_correspondence,</span>
<span class="sd">        #limb_idx_to_branch_meshes_dict = limb_idx_to_branch_meshes_dict,</span>
<span class="sd">        #limb_idx_to_branch_skeletons_dict = limb_idx_to_branch_skeletons_dict,</span>
<span class="sd">        </span>
<span class="sd">        soma_meshes=current_mesh_data[0][&quot;soma_meshes&quot;],</span>
<span class="sd">        soma_idx_connectivity=current_mesh_data[0][&quot;soma_to_piece_connectivity&quot;],</span>
<span class="sd">        #soma_idx_to_mesh_dict = soma_idx_to_mesh_dict,</span>
<span class="sd">        #soma_idx_connectivity = soma_idx_connectivity,</span>
<span class="sd">        </span>
<span class="sd">        current_neuron=current_neuron,</span>
<span class="sd">        return_limb_labels=True</span>
<span class="sd">        )</span>

<span class="sd">#     #Before go and get concept maps:</span>
<span class="sd">#     print(&quot;Sizes of dictionaries sent&quot;)</span>
<span class="sd">#     for curr_limb in limb_idx_to_branch_skeletons_dict.keys():</span>
<span class="sd">#         print((len(limb_idx_to_branch_skeletons_dict[curr_limb]),len(limb_idx_to_branch_meshes_dict[curr_limb])))</span>


<span class="sd">#     print(&quot;\n\n Sizes of concept maps gotten back&quot;)</span>
<span class="sd">#     for curr_idx in limb_concept_networks.keys():</span>
<span class="sd">#         for soma_idx,concept_network in limb_concept_networks[curr_idx].items():</span>
<span class="sd">#             print(len(np.unique(list(concept_network.nodes()))))</span>
<span class="sd">            </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>

<span class="sd">    </span>
<span class="sd">    # ---2) Packaging the data into a dictionary that can be sent to the Neuron class to create the object</span>
<span class="sd">    </span>
<span class="sd">    #Preparing the data structure to save or use for Neuron class construction</span>

<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    preprocessed_data = dict(</span>
<span class="sd">                            soma_meshes = current_mesh_data[0][&quot;soma_meshes&quot;],</span>
<span class="sd">                            soma_to_piece_connectivity = current_mesh_data[0][&quot;soma_to_piece_connectivity&quot;],</span>
<span class="sd">                            soma_sdfs = total_soma_list_sdf,</span>
<span class="sd">                            insignificant_limbs=insignificant_limbs,</span>
<span class="sd">                            non_soma_touching_meshes=non_soma_touching_meshes,</span>
<span class="sd">                            inside_pieces=inside_pieces,</span>
<span class="sd">                            limb_correspondence=limb_correspondence,</span>
<span class="sd">                            limb_concept_networks=limb_concept_networks,</span>
<span class="sd">                            limb_labels=limb_labels,</span>
<span class="sd">                            limb_meshes=current_mesh_data[0][&quot;branch_meshes&quot;],</span>
<span class="sd">                            )</span>

<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    print(f&quot;\n\n\n Total processing time = {time.time() - whole_processing_tiempo}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    print(f&quot;returning preprocessed_data = {preprocessed_data}&quot;)</span>
<span class="sd">    return preprocessed_data</span>
<span class="sd">    </span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">soma_extraction_utils</span> <span class="k">as</span> <span class="n">sm</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">compartment_utils</span> <span class="k">as</span> <span class="n">cu</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshparty_skeletonize</span> <span class="k">as</span> <span class="n">m_sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">python_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>